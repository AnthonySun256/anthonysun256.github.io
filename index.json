[{"categories":["环境配置"],"content":"作为一名炼丹师，我们经常需要使用 Nvidia 显卡辅助我们加速计算，但是 Docker 并不直接支持访问 Nvidia 显卡，但好在 Nvidia 官方提供了提供了相关 Docker 插件可以让我们直接在容器中访问 Nvidia 显卡 ","date":"2022-04-18","objectID":"/docker_with_nvidia/:0:0","tags":["Nvidia","Docker","Ubuntu"],"title":"在 Docker 中使用 Nvidia 显卡","uri":"/docker_with_nvidia/"},{"categories":["环境配置"],"content":"1. 查看安装专有驱动 想要使用 Nvidia 显卡，我们必须先要安装 Nvidia 官方驱动（默认情况下我们使用的是 开源驱动） 安装流程：https://zhuanlan.zhihu.com/p/388970072 ","date":"2022-04-18","objectID":"/docker_with_nvidia/:1:0","tags":["Nvidia","Docker","Ubuntu"],"title":"在 Docker 中使用 Nvidia 显卡","uri":"/docker_with_nvidia/"},{"categories":["环境配置"],"content":"2. 安装 Nvidia-docker 官方仓库：https://github.com/NVIDIA/nvidia-docker 安装指南：https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#docker 注意 本节使用 Ubuntu + docker2作为教程环境，其余发行版请参考官方安装指南 ","date":"2022-04-18","objectID":"/docker_with_nvidia/:2:0","tags":["Nvidia","Docker","Ubuntu"],"title":"在 Docker 中使用 Nvidia 显卡","uri":"/docker_with_nvidia/"},{"categories":["环境配置"],"content":"添加 GPG key 和 源 在终端执行如下指令： $ distribution=$(. /etc/os-release;echo $ID$VERSION_ID) \\ \u0026\u0026 curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \\ \u0026\u0026 curl -s -L https://nvidia.github.io/libnvidia-container/$distribution/libnvidia-container.list | \\ sed 's#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g' | \\ sudo tee /etc/apt/sources.list.d/nvidia-container-toolkit.list 之后更新 apt: $ sudo apt-get update ","date":"2022-04-18","objectID":"/docker_with_nvidia/:2:1","tags":["Nvidia","Docker","Ubuntu"],"title":"在 Docker 中使用 Nvidia 显卡","uri":"/docker_with_nvidia/"},{"categories":["环境配置"],"content":"安装 Nvidia-docker 使用如下指令安装： $ sudo apt-get install -y nvidia-docker2 成功后重启 docker： $ sudo systemctl restart docker 之后可以进行测试： $ sudo docker run --rm --gpus all nvidia/cuda:11.0-base nvidia-smi 应当能看到输出： +-----------------------------------------------------------------------------+ | NVIDIA-SMI 450.51.06 Driver Version: 450.51.06 CUDA Version: 11.0 | |-------------------------------+----------------------+----------------------+ | GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. | | | | MIG M. | |===============================+======================+======================| | 0 Tesla T4 On | 00000000:00:1E.0 Off | 0 | | N/A 34C P8 9W / 70W | 0MiB / 15109MiB | 0% Default | | | | N/A | +-------------------------------+----------------------+----------------------+ +-----------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=============================================================================| | No running processes found | +-----------------------------------------------------------------------------+ ","date":"2022-04-18","objectID":"/docker_with_nvidia/:2:2","tags":["Nvidia","Docker","Ubuntu"],"title":"在 Docker 中使用 Nvidia 显卡","uri":"/docker_with_nvidia/"},{"categories":["环境配置"],"content":"3. 使用说明 官方文档：https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/user-guide.html#gpu-enumeration 与未使用 nvidia 显卡的容器不同之处在于 nvidia-docker 多了一个 --gpus 参数，这个参数标明我们容器中可以使用哪些显卡（如果你的机器上有多张显卡的话） 一般情况下我们使用 docker --gpus all 即可，如果需要特别指名使用哪几张显卡，则可以使用类似 --gpus 0,1 指明使用 GPU UUID 为 0、1 的显卡 此外，根据不同情景需要我们还需要指名要在容器中安装哪些驱动程序或支持库，完整的列表见： https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/user-guide.html#driver-capabilities 比如我们需要 CUDA 和 nvidia-smi+NVML 支持，则需要这样 $ docker run --rm --gpus 'all,\"capabilities=compute,utility\"' \\ nvidia/cuda:11.0-base nvidia-smi 或者这样： # 传递环境变量的方式 $ docker run --rm --runtime=nvidia \\ -e NVIDIA_VISIBLE_DEVICES=2,3 \\ -e NVIDIA_DRIVER_CAPABILITIES=compute,utility \\ nvidia/cuda nvidia-smi 需要注意的是，在已经构建好的 容器 中改变这些环境变量不会有任何效果，如果您需要梗概配置还请 重新构建容器。 ","date":"2022-04-18","objectID":"/docker_with_nvidia/:3:0","tags":["Nvidia","Docker","Ubuntu"],"title":"在 Docker 中使用 Nvidia 显卡","uri":"/docker_with_nvidia/"},{"categories":["环境配置"],"content":"结语 至此，在 Docker 中使用 nvidia 显卡的方法就介绍完毕了，如果您需要在 容器 中使用 Nvidia 相关支持库或者其他功能，则请参考官方文档。 ","date":"2022-04-18","objectID":"/docker_with_nvidia/:4:0","tags":["Nvidia","Docker","Ubuntu"],"title":"在 Docker 中使用 Nvidia 显卡","uri":"/docker_with_nvidia/"},{"categories":null,"content":" 本文适合有 ROS1 基础与了解 urdf语法 和 gazebo 的朋友 SCOUT MINI 是一款全地形高速Mini UGV，具有四轮差速驱动、独立悬挂、原地差速自转等特点，得益于自主研发的轻量级动力系统解决方案，SCOUT MINI最大速度高达10KM/H，专为前沿科学实验设计的全能型移动研究平台。 此外，松灵为用户提供了 SCOUT MINI 的完整 gazebo 仿真支持库，本文将带您逐步上手使用： 仓库地址：https://github.com/agilexrobotics/ugv_gazebo_sim ","date":"2022-04-10","objectID":"/scout_mini_sim/:0:0","tags":["ROS","xacro","松灵机器人"],"title":"Scout mini 仿真指南","uri":"/scout_mini_sim/"},{"categories":null,"content":"1. 开发环境配置 目前官方提供的仿真环境是 ROS-melodic + gazebo9 ，如果您已配置好相关环境请跳过本节。 编者这里使用的开发环境是 docker + VSCode ，这个组合的好处可以参考我的博客文章：Docker 配合 VSC 开发最佳实践 我们首先新建工作空间文件夹，并使用 catkin 初始化工作空间： $ mkdir scout_ws \u0026\u0026 cd scout_ws $ mkdir src .devcontainer $ cd ../.devcontainer 在 .devcontainer 中新建 devcontainer.json 和 Dockerfile 两个文件： $ gedit devcontainer.json # 也可以自行更换其他的编辑器 在 devcontainer.json 保存如下内容： { \"dockerFile\": \"Dockerfile\", \"build\": { \"args\": { \"WORKSPACE\": \"${containerWorkspaceFolder}\" } }, \"remoteUser\": \"ros\", \"runArgs\": [ \"--network=host\", \"--cap-add=SYS_PTRACE\", \"--security-opt=seccomp:unconfined\", \"--security-opt=apparmor:unconfined\", \"--volume=/tmp/.X11-unix:/tmp/.X11-unix\" ], \"containerEnv\": { \"DISPLAY\": \"${localEnv:DISPLAY}\" }, // Set *default* container specific settings.json values on container create. \"settings\": { \"terminal.integrated.profiles.linux\": { \"bash\": { \"path\": \"bash\" }, }, \"terminal.integrated.defaultProfile.linux\": \"bash\" }, \"extensions\": [ \"dotjoshjohnson.xml\", \"zachflower.uncrustify\", \"ms-azuretools.vscode-docker\", \"ms-iot.vscode-ros\", \"ms-python.python\", \"ms-vscode.cpptools\", \"redhat.vscode-yaml\", \"smilerobotics.urdf\", \"streetsidesoftware.code-spell-checker\", \"twxs.cmake\",所有 \"yzhang.markdown-all-in-one\" ] } 其中各个字段的具体含义可以参考我的博文 Docker 配合 VSC 开发最佳实践 $ gedit Dockerfile 在 Dockerfile 中保存以下内容： FROMalthack/ros:melodic-gazebo# Set up auto-source of workspace for ros userARG WORKSPACERUN echo \"if [ -f ${WORKSPACE}/install/setup.bash ]; then source ${WORKSPACE}/install/setup.bash; fi\" \u003e\u003e /home/ros/.bashrc 其中各个字段的具体含义可以参考我的博文 Docker 配合 VSC 开发最佳实践 此时，目录结构如下： scout_ws ├── .devcontainer │ ├── devcontainer.json │ └── Dockerfile └── src 使用 VSC 在 docker 中打开文件夹： $ cd scout_ws $ code . 后续具体操作请见：Docker 配合 VSC 开发最佳实践 最后，需要更新 apt 和 rosdep database $ sudo apt update $ rosdep update ","date":"2022-04-10","objectID":"/scout_mini_sim/:1:0","tags":["ROS","xacro","松灵机器人"],"title":"Scout mini 仿真指南","uri":"/scout_mini_sim/"},{"categories":null,"content":"2. 仿真环境配置 将https://github.com/agilexrobotics/ugv_gazebo_sim/tree/master/scout 中的 scout_control 、scout_description 、scout_gazebo_sim 三个文件放到 src目录之中。 安装如下 ROS 库： $ sudo apt-get -y install --no-install-recommends \\ ros-melodic-ros-control \\ ros-melodic-ros-controllers \\ ros-melodic-gazebo-ros \\ ros-melodic-gazebo-ros-control \\ ros-melodic-joint-state-publisher-gui \\ ros-melodic-teleop-twist-keyboard 然后初始化工作空间并安装依赖： $ cd scout_ws/src $ catkin_init_workspace $ cd .. $ rosdep install --from-paths src --ignore-src -r -y 即可正常编译与运行： $ catkin_make $ source devel/setup.bash scout_description 包主要为 scout 系列车型仿真模型，display_xxx_.launch 为不同车型在 Rviz 中的展示： $ roslaunch scout_description display_mini_models.launch # 在 Rviz 中查看 scout mini 车型 scout_gazebo_sim 包为 scout 系列车型在 gazebo 中的仿真，scout_xxx_.launch 为不同车型在 gazebo 中仿真展示 $ roslaunch scout_gazebo_sim scout_mini_empty_world.launch # 在 gazebo 中使用空地图仿真 scout mini 注意 使用 playpen 地图前需要补全 gazebo 的 models，不然会一直黑屏 ","date":"2022-04-10","objectID":"/scout_mini_sim/:2:0","tags":["ROS","xacro","松灵机器人"],"title":"Scout mini 仿真指南","uri":"/scout_mini_sim/"},{"categories":null,"content":"3. 添加自定义传感 官方的仿真模型中并未添加现成传感器，这也很好理解——车辆上本来就没有，无故添加反而会在实际使用中让人疑惑。 scout 系列车型的 urdf 描述文件位于 scout_description/urdf 中，在这里我们并未直接使用 urdf 文件进行描述，而是从 xacro （xml macro) 描述文件中生成 urdf 信息。使用 xacro 的好处在于我们可以像编程一样实现复用一些 urdf 节点以及将不同的组件拆分等功能。 如果您不了解 xacro，可以先阅读 xacro 语法说明：http://wiki.ros.org/xacr 其相当于扩展了 urdf 的语法，可以以更便捷的方式描述我们的机器人。 下面我将带大家使用 xacro 为小车加上一个简易摄像头： 首先在我们的 scout_description/urdf 中添加一个名为 universal_sensor_adder.xacro 的文件，其中保存如下内容： \u003c?xml version=\"1.0\"?\u003e \u003c!-- Author: AnthonySuen Date: 2020-4-8 --\u003e \u003crobot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"universal_sensor_adder\"\u003e \u003c!-- 用于生成一个新的传感器节点, x_offset y_offset z_offset r p y对应于传感器和 base_link 的相对位置 sensor_config 为传感器的配置信息 sensor_plugin_config 为 gazebo 相关插件的配置内容 --\u003e \u003cxacro:macro name=\"add_sensor\" params=\"sensor_name type x_offset y_offset z_offset r p y **sensor_config **sensor_plugin_config\"\u003e \u003clink name=\"sensor_${sensor_name}\"\u003e \u003c!-- 配置传感器视觉信息 --\u003e \u003cvisual\u003e \u003cgeometry\u003e \u003cbox size=\"0.03 0.05 0.05\"/\u003e \u003c/geometry\u003e \u003cmaterial name=\"red\"\u003e \u003ccolor rgba=\"1.0 0.0 0.0 1.0\"/\u003e \u003c/material\u003e \u003c/visual\u003e \u003c!-- 配置碰撞体积, 为gazebo仿真使用 --\u003e \u003ccollision\u003e \u003corigin xyz=\"0.0 0.0 0.0\" rpy=\"0.0 0.0 0.0\"/\u003e \u003cgeometry\u003e \u003cbox size=\"0.03 0.05 0.05\"/\u003e \u003c/geometry\u003e \u003c/collision\u003e \u003c!-- 配置惯性矩阵, 用于 gazebo 仿真,这里我假设传感器很轻很小 --\u003e \u003cinertial\u003e \u003corigin xyz=\"0.0 0.0 0.0\" rpy=\"0.0 0.0 0.0\"/\u003e \u003cmass value=\"1e-5\"/\u003e \u003cinertia ixx=\"1e-6\" ixy=\"1e-6\" ixz=\"1e-6\" iyy=\"1e-6\" iyz=\"1e-6\" izz=\"1e-6\"/\u003e \u003c/inertial\u003e \u003c/link\u003e \u003c!-- 配置关节信息, 这里我默认传感器是固定在车上的 --\u003e \u003cjoint name=\"sensor_${sensor_name}_joint\" type=\"fixed\"\u003e \u003cparent link=\"base_link\"/\u003e \u003cchild link=\"sensor_${sensor_name}\"/\u003e \u003corigin xyz=\"${x_offset} ${y_offset} ${z_offset}\" rpy=\"${r} ${p} ${y}\"/\u003e \u003c/joint\u003e \u003c!-- gazebo 配置仿真配置部分 --\u003e \u003cgazebo reference=\"sensor_${sensor_name}\"\u003e \u003c!-- 此部分要与 传感器 link 名称保持一致 --\u003e \u003csensor name=\"${sensor_name}\" type=\"${type}\"\u003e \u003c!-- 这里会插入传感器自身配置信息和相关插件的配置内容 --\u003e \u003cxacro:insert_block name=\"sensor_config\"/\u003e \u003cxacro:insert_block name=\"sensor_plugin_config\"/\u003e \u003c/sensor\u003e \u003c/gazebo\u003e \u003c/xacro:macro\u003e \u003c/robot\u003e 注意 请在使用时删除中文注释，xacro 无法解析非 ascii 字符！ 编辑 empty.urdf 文件，修改其中内容如下： \u003c?xml version=\"1.0\"?\u003e \u003c!-- Author: AnthonySuen Date: 2020-4-8 --\u003e \u003crobot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"sensors\"\u003e \u003c!-- 加载我们之前编写的文件，之后可以使用其中相关内容 --\u003e \u003cxacro:include filename=\"$(find scout_description)/urdf/universal_sensor_adder.xacro\" /\u003e \u003c!-- 使用我们编写的函数，填入相关参数 --\u003e \u003cxacro:add_sensor sensor_name=\"camera\" type=\"camera\" x_offset=\"0.1\" y_offset=\"0.0\" z_offset=\"0.085\" r=\"0.0\" p=\"0.0\" y=\"0.0\"\u003e \u003c!-- 这部分会替换 \u003cxacro:insert_block name=\"sensor_config\"/\u003e 中的内容 --\u003e \u003csensor_config\u003e \u003cupdate_rate\u003e30\u003c/update_rate\u003e \u003ccamera name=\"general_camera\"\u003e \u003cimage width=\"640\" height=\"480\" hfov=\"1.5708\" format=\"RGB8\" near=\"0.01\" far=\"50.0\"/\u003e \u003c/camera\u003e \u003c/sensor_config\u003e \u003c!-- 这部分会替换 \u003cxacro:insert_block name=\"sensor_plugin_config\"/\u003e 中的内容 --\u003e \u003csensor_plugin_config\u003e \u003cplugin name=\"general_camera_controller\" filename=\"libgazebo_ros_camera.so\"\u003e \u003calwaysOn\u003etrue\u003c/alwaysOn\u003e \u003cupdateRate\u003e36.0\u003c/updateRate\u003e \u003ccameraName\u003esensor_camera\u003c/cameraName\u003e \u003cimageTopicName\u003eimage_raw\u003c/imageTopicName\u003e \u003ccameraInfoTopicName\u003ecamera_info\u003c/cameraInfoTopicName\u003e \u003cframeName\u003esensor_camera\u003c/frameName\u003e \u003c!-- 需要与 传感器 link 名称保持一致 --\u003e \u003chackBaseline\u003e0.1\u003c/hackBaseline\u003e \u003cdistortionK1\u003e0.0\u003c/distortionK1\u003e \u003cdistortionK2\u003e0.0\u003c/distortionK2\u003e \u003cdistortionK3\u003e0.0\u003c/distortionK3\u003e \u003cdistortionT1\u003e0.0\u003c/distortionT1\u003e \u003cdistortionT2\u003e0.0\u003c/distortionT2\u003e \u003c/plugin\u003e \u003c/sensor_plugin_config\u003e \u003c/xacro:add_sensor\u003e \u003c/robot\u003e empty.urdf 会在我们模型生成的时候被 mini.xacro 等车辆描述文件加载，所以我们不用去更改其他模型文件，这样保持了开发的整洁性 注意 请在使用时删除中文注释，xacro 无法解析非 ascii 字符 之后运行一下 Rivz 查看我们修改后的模型： $ roslaunch scout_description display_mini_models.launch 可以看到车辆头顶出了一个红色小方块，这就是我们的简易摄像头模型 也可以在 gazebo 中仿真并用 Rviz 接收图像： $ roslaunch scout_gazebo_sim scout_mini_playpen.launch 至此，便完成了添加传感器并进行仿真的全部流程，对于其他类型传感器，诸如 深度相机 激光雷达 imu 等，其添加方法一样方便，唯一不同点在我们编写的函数中 sensor_config 与 sensor_plugin_config 块中对于不同传感器的配置，简单修改即可适配不同传感器。 ","date":"2022-04-10","objectID":"/scout_mini_sim/:3:0","tags":["ROS","xacro","松灵机器人"],"title":"Scout mini 仿真指南","uri":"/scout_mini_sim/"},{"categories":["开发技巧","环境配置"],"content":"由于一些原因，我们常常需要在开发中使用代理，但是在实践过程中我们发现在 Container 中我们无法直接使用主机配置好的代理。本文将给出不同平台下配置 Container 中的代理的方法。 警告 本文的目的是为工作提供方便，很多公司开发过程中都需要使用代理连接内部资源服务器，请勿将本文所述内容用于违法用途！ 对此产生的任何影响本人概不负责！ ","date":"2022-01-26","objectID":"/docker-proxy-complete-solution/:0:0","tags":["Docker","Docker-Desktop","Container","proxy"],"title":"Docker Container 代理配置一本通","uri":"/docker-proxy-complete-solution/"},{"categories":["开发技巧","环境配置"],"content":"综述 对于 Container 的配置分为两种情况： 使用Dockerfile/Docker-compose分步构建过程中是需要使用代理 例如需要使用公司内部镜像下载软件包 构建好的容器需要使用代理 对于上述两种情况，经过查阅 Docker 相关文档，所有平台下对 Container 的代理配置都可以转化为一个操作： 在 Container 中设置 http_proxy / https_proxy 这两个环境变量 注意 注意这里的大小写，如果只设置了 HTTP_proxy / HTTPS_proxy 可能在某些情况下无法正常工作，当然您也可以一块儿将这四个变量都设置了，不影响的。 ","date":"2022-01-26","objectID":"/docker-proxy-complete-solution/:1:0","tags":["Docker","Docker-Desktop","Container","proxy"],"title":"Docker Container 代理配置一本通","uri":"/docker-proxy-complete-solution/"},{"categories":["开发技巧","环境配置"],"content":"配置方法 Docker 支持设定时给每个新构建的 Container 传递永久环境变量，有些人利用这一点直接传递 xxxx_proxy，但是我不希望你这样做 永久环境变量可能出现的问题 如果你构建的镜像内部永久配置了 http_proxy 等 代理环境变量，那可能会导致你的镜像在别人那里运行就会出现网络问题，而对方可能对 Docker 或者 Linux 理解不深从而没有办法修复这个问题，这不符合一次构建到处运行的理念。 在正式开始之前，我们需要确定我们的代理已经允许了本地 LAN 并配置好了端口： ","date":"2022-01-26","objectID":"/docker-proxy-complete-solution/:2:0","tags":["Docker","Docker-Desktop","Container","proxy"],"title":"Docker Container 代理配置一本通","uri":"/docker-proxy-complete-solution/"},{"categories":["开发技巧","环境配置"],"content":"确定 http(s)_proxy 地址 在实际的使用中，我们需要传递的环境变量 http_proxy 和 https_proxy （当然，你也可以继续传递 类似 ftp_proxy 等内容） 这时候对于不同平台我们需要使用不同的地址： Windows / MacOs： 由于在这两个平台下 Docker 通过 NAT 的方式连接网络，我们无法获取一个固定的网关地址，所以 Docker-Desktop 为我们提供了一个访问网关的网址：gateway.docker.internal，所以我们直接使用这个地址即可。 示例 https_proxy=\"https://gateway.docker.internal:7890\" http_proxy=\"http://gateway.docker.internal:7890\" Linux Linux 下 docker 服务默认会创建一个 docker0 网桥，我们可以通过这个网桥让容器和主机进行通信，只需要在命令行输入： $ ip addr show docker0 就可以看到 docker0 的信息： 4: docker0: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc noqueue state UP group default link/ether 02:42:84:54:33:33 brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever inet6 fe80::42:84ff:fe54:3333/64 scope link valid_lft forever preferred_lft forever 这里面 inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 就表示我们容器的网关为 172.17.0.1，我们使用网关即可直接访问我们主机： 示例 https_proxy=\"https://172.17.0.1:7890\" http_proxy=\"http://172.17.0.1:7890\" ","date":"2022-01-26","objectID":"/docker-proxy-complete-solution/:2:1","tags":["Docker","Docker-Desktop","Container","proxy"],"title":"Docker Container 代理配置一本通","uri":"/docker-proxy-complete-solution/"},{"categories":["开发技巧","环境配置"],"content":"从 Dockerfile 构建 注意 以下示例均已 Linux 的为例，Windows/MacOs 用于请自行替换相应的地址！，怎么确定请往上面看！确定 http(s)_proxy 地址 1. 永久传递环境变量 使用 ENV 参数，这样传递进去的参数在此之后会一直留存在镜像之中： FROMubuntu as base# 放在开头，之后的指令就都会被这两条环境变量影响ENV https_proxy=\"https://172.17.0.1:7890\"ENV http_proxy=\"http://172.17.0.1:7890\"# 其余命令 2. 仅在构建时传递 使用 ARG 参数，这样两条代理指令仅在构建过程中起效，构建结束后的 Image 中不会留存相关环境变量： FROMubuntu as base# 放在开头，之后的指令就都会被这两条环境变量影响ARG https_proxy=\"https://172.17.0.1:7890\"ARG http_proxy=\"http://172.17.0.1:7890\"# 其余命令 ","date":"2022-01-26","objectID":"/docker-proxy-complete-solution/:2:2","tags":["Docker","Docker-Desktop","Container","proxy"],"title":"Docker Container 代理配置一本通","uri":"/docker-proxy-complete-solution/"},{"categories":["开发技巧","环境配置"],"content":"构建好的 Image 注意 以下示例均已 Linux 的为例，Windows/MacOs 用于请自行替换相应的地址！，怎么确定请往上面看！确定 http(s)_proxy 地址 对于已经构建好的 Image，我们对其配置代理有两种方式： 1. 传递永久环境变量 在启动的时候传入参数： 示例 $ docker run --rm -it\\ -e https_proxy=\"https://gateway.docker.internal:7890\"\\ -e http_proxy=\"http://gateway.docker.internal:7890\"\\ ubuntu # 这里换成你需要的image名 当然，您可也可以将这写环境变量写成一个 .env 文件然后使用 --env-file 去统一导入： 例如 Linux 下.env 文件： http_proxy=\"http://172.17.0.1:7890\" https_proxy=\"https://172.17.0.1:7890\" 之后这要进行导入： $ docker run --rm -it --env-file .env ubuntu 2. 临时传递 临时传递的方式较为简单，只需要先运行镜像： $ docker run --rm -it ubuntu 在进入镜像后手动设置环境变量： $ export http_proxy=\"http://172.17.0.1:7890\" $ export https_proxy=\"https://172.17.0.1:7890\" 或者配合 VSCode 的 Remote-Container 插件配置后可以实现每次自动设置，具体方式请移步 Docker 配合 VSC 开发最佳实践 ","date":"2022-01-26","objectID":"/docker-proxy-complete-solution/:2:3","tags":["Docker","Docker-Desktop","Container","proxy"],"title":"Docker Container 代理配置一本通","uri":"/docker-proxy-complete-solution/"},{"categories":["开发技巧","环境配置"],"content":"已生成的 Container 注意 以下示例均已 Linux 的为例，Windows/MacOs 用于请自行替换相应的地址！，怎么确定请往上面看！确定 http(s)_proxy 地址 1. 永久设定环境变量 修改 /etc/profile 或者 ~/.bashrc 文件，在其中加入 export http_proxy=\"http://172.17.0.1:7890\" export https_proxy=\"https://172.17.0.1:7890\" 2. 临时设定 在进入镜像后手动设置环境变量： $ export http_proxy=\"http://172.17.0.1:7890\" $ export https_proxy=\"https://172.17.0.1:7890\" 或者配合 VSCode 的 Remote-Container 插件配置后可以实现每次自动设置，具体方式请移步 Docker 配合 VSC 开发最佳实践 ","date":"2022-01-26","objectID":"/docker-proxy-complete-solution/:2:4","tags":["Docker","Docker-Desktop","Container","proxy"],"title":"Docker Container 代理配置一本通","uri":"/docker-proxy-complete-solution/"},{"categories":["开发技巧","环境配置"],"content":"结语 以上就是配置 Docker 容器代理的全部方法，经过实践真实可用 ","date":"2022-01-26","objectID":"/docker-proxy-complete-solution/:3:0","tags":["Docker","Docker-Desktop","Container","proxy"],"title":"Docker Container 代理配置一本通","uri":"/docker-proxy-complete-solution/"},{"categories":null,"content":"emm…看起来这里还有写完 ","date":"2022-01-23","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":["开发技巧"],"content":"前言 ","date":"2022-01-23","objectID":"/docker-with-vsc_best-practice/:1:0","tags":["Docker","VSCode"],"title":"Docker配合VSC开发最佳实践","uri":"/docker-with-vsc_best-practice/"},{"categories":["开发技巧"],"content":"为什么我们需要虚拟环境？ 很长时间以来最让我头疼的事情就是配置开发环境，最简单的一个例子是配置深度学习使用的 Python 环境。如果在本机上直接配置 Python 环境很容易出现各种问题，例如 Pytorch 和 Tensorflow 可能会同时依赖某个库的不同版本，这就会导致可能只有特定版本 Pytorch 和 Tensorflow 才有机会共存，而你在安装的时候很可能都没有意识到这个问题。 直到你运行某段代码时 Python 解释器给你报了几百行的错误你才意识哪里出了点问题，但是你又不知道是什么，于是你就会花上几天的时间改代码、查资料，最后你明白是你的环境配置有问题，于是又手动清理之前安装错误的 Python 库，并尝试重新运行之前的代码。 警告 当然，更多的时候这会开启新一个痛苦的轮回 Python 环境配置建议 所幸，现在我们可以使用 Anaconda 进行 Python 环境管理，不同的环境相互隔离以免出现冲突。conda 对于依赖的检查也比 pip 更好用，基本上不会出现依赖冲突问题 这一套的流程下来我相信无论是谁也受不了，但是环境问题远不止如此 环境问题示例 某段代码只能在某几个特定的电脑上才能运行 某段代码你睡了一觉后就无法运行了 你辛苦配了好久的环境不好使了/需要换电脑了/需要给别人也整一份 你有两项工作要做，但是这两项工作需要安装的包是冲突的，而且重新安装极其麻烦 你安装了某个包，然后你的操作系统就出了问题，即使卸载这个包也没有用 你想在 Linux 上使用 N卡 于是你按照网上的教程配置了显卡，然后你的显卡就不好使了 某个古董程序只能在老版 Linux 上运行 …… 应对以上问题，我们当然可以简单的给电脑做多系统/每次重装系统/买新的电脑来解决，但更为经济的做法是使用容器技术。 ","date":"2022-01-23","objectID":"/docker-with-vsc_best-practice/:1:1","tags":["Docker","VSCode"],"title":"Docker配合VSC开发最佳实践","uri":"/docker-with-vsc_best-practice/"},{"categories":["开发技巧"],"content":"Docker VS 虚拟机 快 Docker 的启停都是以秒或者毫秒为单位的，诸如 VM 等软件的启停最少也需要几分钟的时间 只要使用一行指令 / 一个 Dockerfile/docker-compose 文件 即可快速启动/部署我们的环境 轻量 Docker 环境不需要虚拟完整的操作系统或者硬件镜像体积天生就小，且基于联合文件系统可以让不同镜像间使用到的相同文件进行共用，进一步压缩了镜像体积。（一些常用的开发环境甚至只有不到 100M） 虚拟机需要大量的资源去虚拟完整的操作系统甚至是硬件无法实现多开；Docker 只占用很少的运行时资源，一台机器可以开启少则几十多则几百上千个 Docker Container 快速回滚 容器技术天生带有回滚属性，因为每个历史容器或者镜像都会有保存，而替换一个容器或者某个历史镜像是非常快速和简单的，你可以快速回到某一次的更改 隔离性强 一台机器上可以启动多个 Docker 容器，而且容器之间环境隔离不会互相干扰 易分享 你只需要将你的 Container 镜像推送到云端或者直接分享给你的 Dockerfile/docker-compose 文件给其他人即可让其他人在几分钟内快速部署和你相同的环境 你能够保证其他人都能使用和你一模一样的镜像 Docker 是跨平台的产品，同样的镜像可以在 Windows / MacOs / Linux 上同时使用，而且效果相同 低成本 一台机器上可以启动几十上百个 Docker 容器 使用 Docker Swarm / K8s 等编排工具可以快速编排管理成百上千的容器 ","date":"2022-01-23","objectID":"/docker-with-vsc_best-practice/:1:2","tags":["Docker","VSCode"],"title":"Docker配合VSC开发最佳实践","uri":"/docker-with-vsc_best-practice/"},{"categories":["开发技巧"],"content":"VSCode 与 Docker 结合 VSCode 是什么相信我不必多言，依托于其 Remote Container 插件，我们可以快速地（真的很快🚀）连接到 Docker 容器中去，实现在本地编写程序，一键容器中调试运行——而这一切跟你直接在宿主机上开发几乎一模一样。而用虚拟机的话光是不同屏幕之间切换以及文件同步之类的操作就够惹人烦了。 再者，配合 VSCode 原生的 launch 和 task 配置并绑定相应段快捷键，我们可以节省很多应用编译时需要进行的操作（比如输入编译指令、清理目录等） ","date":"2022-01-23","objectID":"/docker-with-vsc_best-practice/:1:3","tags":["Docker","VSCode"],"title":"Docker配合VSC开发最佳实践","uri":"/docker-with-vsc_best-practice/"},{"categories":["开发技巧"],"content":"Docker 学习 Docker 网络上的教程有很多，我相信我很难讲出比现有课程更好的效果，在这里我只推荐我认为讲的最好的一个课程，内容精简实践性强，大概花上两个下午就能学完。 【狂神说Java】Docker最新超详细版教程通俗易懂 以及进阶版： 【狂神说Java】Docker进阶篇超详细版教程通俗易懂 学完了这两门课程我相信你基本上能够熟练地是使用 Docker 了，下一节我们来说如何让 VSCode 连接 Docker 环境 ","date":"2022-01-23","objectID":"/docker-with-vsc_best-practice/:2:0","tags":["Docker","VSCode"],"title":"Docker配合VSC开发最佳实践","uri":"/docker-with-vsc_best-practice/"},{"categories":["开发技巧"],"content":"VSCode 连接 Container 注意 在进行本节内容之前请先确保你已经学会了 Docker 相关知识 ","date":"2022-01-23","objectID":"/docker-with-vsc_best-practice/:3:0","tags":["Docker","VSCode"],"title":"Docker配合VSC开发最佳实践","uri":"/docker-with-vsc_best-practice/"},{"categories":["开发技巧"],"content":"Remote Containers 插件安装 插件市场插件市场 \" 插件市场 打开插件市场（图中 ① 箭头所示） 在搜索框输入 container 搜索插件（图中 ③ 所示） 找到 Remote-Containers 插件在打开的页面中安装插件（途中 ② 所示） 等待插件安装成功之后应该能发现在 VSCode 左下角出现一个新的小图标，左边也出现了一个 Docker 图标 新图标新图标 \" 新图标 ","date":"2022-01-23","objectID":"/docker-with-vsc_best-practice/:3:1","tags":["Docker","VSCode"],"title":"Docker配合VSC开发最佳实践","uri":"/docker-with-vsc_best-practice/"},{"categories":["开发技巧"],"content":"Remote Containers 插件使用 严格上来讲本节内容是对 Remote-Containers 插件 官方文档 的翻译与浓缩。 初体验 在 https://github.com/microsoft/vscode-remote-try-python 下载解压官方示例仓库并使用 VSCode 打开文件夹，您应该得到如下组织的目录： . │ .gitattributes │ .gitignore │ app.py │ LICENSE │ README.md │ requirements.txt │ ├─.devcontainer │ devcontainer.json │ Dockerfile │ ├─.vscode │ launch.json │ └─static index.html 在根目录用 VS Code 打开文件夹，然后点击左下角的图标 点击新图标点击图标 \" 点击新图标 在弹出的窗口中选择 Reopen in Container 在容器中打开在容器中打开 \" 在容器中打开 VS Code 会根据 .devcontainer 文件夹中的 Dockerfile 和 devcontainer.json 自动拉取并配置镜像环境，点击蓝色字样（show log）可以查看当前环境构建进度 点击查看当前构建过程点击查看当前构建过程 \" 点击查看当前构建过程 首先 VS Code 会根据 Dockerfile 文件描述进行 build image 并 docker run 生成 container 根据 Dockerfile 构建镜像根据 Dockerfile 构建镜像 \" 根据 Dockerfile 构建镜像 紧接着，VS Code 会根据 devcontainer.json 文件中的描述进行一些配置工作，比如这里会在 container 首次运行的时候执行 $ pip3 install -r requirements.txt 来安装运行 python 程序需要的支持库 首次启动首次启动 \" 首次启动 以及会根据 devcontainer.json 中的配置为我们的 container 自动安装一些插件，比如这里会提示 Pylance 需要重新加载窗口来激活： Pylance 提示Pylance 提示 \" Pylance 提示 这里我们选择 是 等待窗口加载完毕后点击窗口左侧的 运行和调试功能 运行与调试按钮运行与调试按钮 \" 运行与调试按钮 点击 开始调试 ，VS Code 会自动帮我们运行这个 python 程序 开始调试开始调试 \" 开始调试 关于 VS Code 的调试功能和 Task 功能是另外的话题，我会单独讲解，这里不会深入。 这时候我们发现 VS Code 帮我们自动转发了 python 程序提供的端口（真的非常方便✨） 端口自动转发端口自动转发 \" 端口自动转发 点击在 浏览器中打开 即可看到这段程序提供的网页内容： 而这一切只会花费不到五分钟（根据网速而定），而且不会对宿主机产生任何影响！ devcontainer.json 探究 Dockerfile 在 Docker 学习 章节已经讲过了，这里我就不介绍了。我们主要来探究 devcontain.json 到底讲了什么故事。 详细文档和例子请见 https://aka.ms/vscode-remote/devcontainer.json ，这里我们主要来看一下常用的一些配置信息： name 当前工作空间名称，会显示在左下角 build dockerfile： 用于指定 dockerfile 文件的路径，这里是相对于 devcontainer.json 文件而言 context：用于指定 docker build 时的上下文路径，这里是相对于 devcontainer.json 文件而言 args：用于在 docker build 时传递参数 settings 用于设定容器中 settings.json 的默认值，比如这里设定了使用的 shell 路径和 python 插件的配置 extensions 用于指定在容器中安装的插件，比如这里会自动帮我们安装 pylance 插件 portsAttributes 用于设定端口属性，比如名称，映射时的行为，也可以用 forwardPorts 简单代替 postCreateCommand 在容器第一次启动时执行的指令，这里会自动安装依赖，只会执行这一次 remoteUser 登录到容器的用户名，默认情况下是 root 用户登录，但是有时我们不想这样，可以利用这个指定远程用户名（这个用户必须存在才行） 此外，还有一些字段也很有用： runArgs docker run 时传递的参数，用于类似设定 –network=host 等操作 containerEnv / remoteEnv 用于设定容器中的环境变量，比如设定 http_proxy 等环境变量的值 ","date":"2022-01-23","objectID":"/docker-with-vsc_best-practice/:3:2","tags":["Docker","VSCode"],"title":"Docker配合VSC开发最佳实践","uri":"/docker-with-vsc_best-practice/"},{"categories":["开发技巧"],"content":"显示 Docker 中的图形界面 很多时候我们都需要查看 docker 中的图形界面，这里我们直接使用 X11 让 docker 中的 GUI 直接在宿主机上运行（相比于 VNC 方案更加轻量化） 现成的方案有这几个： 在docker中通过X11运行gui程序 Docker X11 穿透方案 上面两个文章讲了原理和操作方法，下面给出如何在 VS Code 中配置 首先我们在 devcontainer.json 中的 runArgs 字段中添加 \"--volume=/tmp/.X11-unix:/tmp/.X11-unix\" 表示挂载 x11 相关目录到容器中 containerEnv 字段中添加 \"DISPLAY\": \"${localEnv:DISPLAY}\" 表示设定容器中的 DISPLAY 环境变量与本地 DISPLAY 为一样的值 在 Dockerfile 中添加如下内容： # 来源：https://github.com/athackst/dockerfiles/blob/main/ros2/foxy.Dockerfile################# Expose the nvidia driver to allow opengl # Dependencies for glvnd and X11.################RUN apt-get update \\ \u0026\u0026 apt-get install -y -qq --no-install-recommends \\ libglvnd0 \\ libgl1 \\ libglx0 \\ libegl1 \\ libxext6 \\ libx11-6# Env vars for the nvidia-container-runtime.ENV NVIDIA_VISIBLE_DEVICES allENV NVIDIA_DRIVER_CAPABILITIES graphics,utility,computeENV QT_X11_NO_MITSHM 1 至此即可完成将容器中 GUI 显示在宿主机的操作！ ","date":"2022-01-23","objectID":"/docker-with-vsc_best-practice/:4:0","tags":["Docker","VSCode"],"title":"Docker配合VSC开发最佳实践","uri":"/docker-with-vsc_best-practice/"},{"categories":["开发技巧"],"content":"结语 至此 Docker 配合 VSCode 开发的内容就讲解完毕了，如果大家觉得有哪里需要改进或者拓展的地方还请在评论区提出，我会及时回复 ","date":"2022-01-23","objectID":"/docker-with-vsc_best-practice/:5:0","tags":["Docker","VSCode"],"title":"Docker配合VSC开发最佳实践","uri":"/docker-with-vsc_best-practice/"},{"categories":null,"content":" 基本信息 - nickname:Anthonyavatar:https://anthonysun256.github.io/images/avatar.jpgurl:https://anthonysun256.github.iodiscription:Anthony's blog ","date":"0001-01-01","objectID":"/friends/:0:0","tags":null,"title":"友情链接","uri":"/friends/"},{"categories":null,"content":"友情提醒 互换友链请按以上格式在评论留言。（仅限个人非商业博客/网站） 提醒：网站失效、停止维护、内容不当都可能被取消连接！ 那些不尊重他人劳动成果，转载不加出处的，或恶意行为的网站，还请您不要来进行交换了。 ","date":"0001-01-01","objectID":"/friends/:1:0","tags":null,"title":"友情链接","uri":"/friends/"}]