[{"categories":null,"content":"在 ROS 开发过程中（尤其是在多人团队中）你一定遇到过这样的问题：需要快速（在不同架构机器上）部署相同开发环境、别人电脑上可以编译但到了自己这里就会报错、无法复现别人的 Bug、经常会出现缺少支持库或者支持库冲突的情况，尤其是一台电脑上需要做多种任务的情况（比如 深度学习、QT 开发、ROS1、ROS2）则会更糟糕…… 这个时候我们就有必要使用 Docker 进行开发 无论您之前使用什么样的方式进行开发，笔者在这里都推荐您尝试 Docker + VSCode，虽然这可能需要两三个下午的时间进行学习，但请相信这一切都是值得的！ 如果您不会使用 docker 或者没有尝试过类似的操作，请您先阅读 《Docker 配合 VSC 开发最佳实践》(https://anthonysun256.github.io/docker-with-vsc_best-practice/) ","date":"2022-05-06","objectID":"/ros-docker-dev-instruct/:0:0","tags":null,"title":"一步到位解决开发环境一致性问题","uri":"/ros-docker-dev-instruct/"},{"categories":null,"content":"1. 镜像选取 Docker 官方镜像服务器上有很多的 ROS 开发镜像，这里我们可以有如下选择（这几个镜像也是笔者常用的）： ROS 官方镜像：https://hub.docker.com/_/ros 内含所有 ROS 发行版的基础开发镜像，而且支持多种架构，非常适合在多种架构的机器上进行部署。 althack 的开发镜像 https://hub.docker.com/u/althack 98 althack 提供了 VSCode 的开发工作环境模板：https://github.com/athackst/vscode_ros2_workspace 虽然模板是 ROS2 但是只要简单修改 Dockerfile 中引用的镜像名称即可改成 ROS1 环境 Dockerfile 源码：https://github.com/athackst/dockerfiles 这个镜像优点是提供了 ROS-desktop-full 的开发环境，省去了自行安装的麻烦，非常适合学习使用。缺点是只支持 PC，如果其他环境需要自己使用 Dockerfile 编译。 ","date":"2022-05-06","objectID":"/ros-docker-dev-instruct/:1:0","tags":null,"title":"一步到位解决开发环境一致性问题","uri":"/ros-docker-dev-instruct/"},{"categories":null,"content":"2. 开发环境搭建 我们新建的工作空间目录格式如下： . ├── .devcontainer # docker 配置文件 │ ├── devcontainer.json │ └── Dockerfile └── src # ROS 源码目录 VSCode 会自动读取 .devcontainer 中的配置文件。对于我个人学习而言我一直使用的是 https://hub.docker.com/u/althack 的镜像和配置，下面的配置文件也是改变于此，各位读者可以根据自己的需要进行修改： Dockerfile： # 改编自 https://github.com/athackst/vscode_ros2_workspace# 我使用的 ROS 学习镜像，根据您的喜好可以自行更改FROMalthack/ros:melodic-gazebo as gazebo # ** [可选] 取消注释安装其他组件 **## ENV DEBIAN_FRONTEND=noninteractive# RUN apt-get update \\# \u0026\u0026 apt-get -y install --no-install-recommends \u003cyour-package-list-here\u003e \\# ## # Clean up# \u0026\u0026 apt-get autoremove -y \\# \u0026\u0026 apt-get clean -y \\# \u0026\u0026 rm -rf /var/lib/apt/lists/*# ENV DEBIAN_FRONTEND=dialog# 为 ros 用户配置自动 sourceARG WORKSPACERUN echo \"if [ -f ${WORKSPACE}/install/setup.bash ]; then source ${WORKSPACE}/install/setup.bash; fi\" \u003e\u003e /home/ros/.bashrc 如果需要 GPU 支持（需要安装 nvidia-docker [ https://anthonysun256.github.io/docker_with_nvidia/ ] 则在上述脚本之后追加如下指令： RUN apt-get update \\ \u0026\u0026 apt-get install -y -qq --no-install-recommends \\ libglvnd0 \\ libgl1 \\ libglx0 \\ libegl1 \\ libxext6 \\ libx11-6 \\ \u0026\u0026 apt-get autoremove -y \\ \u0026\u0026 apt-get clean -y \\ \u0026\u0026 rm -rf /var/lib/apt/lists/*ENV DEBIAN_FRONTEND=dialog # Nvidia 运行时变量.ENV NVIDIA_VISIBLE_DEVICES allENV NVIDIA_DRIVER_CAPABILITIES graphics,utility,computeENV QT_X11_NO_MITSHM=1 devcontainer.json // 改编自 https://github.com/athackst/vscode_ros2_workspace // See https://aka.ms/vscode-remote/devcontainer.json for format details. { \"dockerFile\": \"Dockerfile\", \"build\": { \"args\": { \"WORKSPACE\": \"${containerWorkspaceFolder}\" } }, \"remoteUser\": \"ros\", \"runArgs\": [ \"--network=host\", \"--cap-add=SYS_PTRACE\", \"--cap-add=SYS_RAWIO\", \"--privileged=true\", \"--security-opt=seccomp:unconfined\", \"--security-opt=apparmor:unconfined\", \"--volume=/tmp/.X11-unix:/tmp/.X11-unix\", // \"--gpus\" \"all\", // 取消该注释使用 GPU 功能 \"--device=/dev/bus/usb:/dev/bus/usb\", // 挂载外部硬件，比如摄像头，根据需要修改路径 ], \"containerEnv\": { \"DISPLAY\": \"${localEnv:DISPLAY}\" }, // Set *default* container specific settings.json values on container create. \"settings\": { \"terminal.integrated.profiles.linux\": { \"bash\": { \"path\": \"bash\" }, }, \"terminal.integrated.defaultProfile.linux\": \"bash\" }, // 推荐安装的插件 \"extensions\": [ \"dotjoshjohnson.xml\", \"zachflower.uncrustify\", \"ms-azuretools.vscode-docker\", \"ms-iot.vscode-ros\", \"ms-python.python\", \"ms-vscode.cpptools\", \"redhat.vscode-yaml\", \"smilerobotics.urdf\", \"streetsidesoftware.code-spell-checker\", \"twxs.cmake\", \"yzhang.markdown-all-in-one\" ] } ","date":"2022-05-06","objectID":"/ros-docker-dev-instruct/:2:0","tags":null,"title":"一步到位解决开发环境一致性问题","uri":"/ros-docker-dev-instruct/"},{"categories":null,"content":"3. 启动开发环境 我们使用 VSCode 打开文件夹，并且 Reopen in docker 即可（不要自己只使用 Dockerfile 进行构建，因为在 devcontainer.json 中我们还挂载了一些目录，添加了一些参数） 根据网络状况不同初次启动这里可能需要等待 VSCode 安装一些组件，请耐心等待，下次启动即可极速启动 部分挂载的设备可能需要 root 权限才能访问，这一点需要注意 ","date":"2022-05-06","objectID":"/ros-docker-dev-instruct/:3:0","tags":null,"title":"一步到位解决开发环境一致性问题","uri":"/ros-docker-dev-instruct/"},{"categories":null,"content":"4. 查看图形界面 在我们的主机中，打开一个终端，运行 xhost + 之后在我们 VSCode 中的命令行中随便打开一个图形界面，比如 rqt，可以看到 rqt 直接显示在了我们的屏幕上 对于 Rviz 和 Gazebo，如果您的电脑上没有显卡、未正确安装闭源显卡驱动或者没有正确开启 nvidia-docker 显卡功能那界面会很卡，这和用不用 Docker 没有关系 ","date":"2022-05-06","objectID":"/ros-docker-dev-instruct/:4:0","tags":null,"title":"一步到位解决开发环境一致性问题","uri":"/ros-docker-dev-instruct/"},{"categories":null,"content":"5.插件简介 笔者的 devcontainer.json 中会为大家安装一些实用插件，这部分我们简略了解一下 ROS——这个插件可以帮助我们快速更新 VSCode 中有关 ROS include 的路径，而且提供了图形界面查看 ROS 话题、服务等 按下 shift+ctrl+p 呼出快捷命令栏，输入 ros，可以看到自动更新选项 yaml xml xacro 语法助手 这个可说的不多，能够帮助我们快速编写相应的文件，为其提供智能补全 ","date":"2022-05-06","objectID":"/ros-docker-dev-instruct/:5:0","tags":null,"title":"一步到位解决开发环境一致性问题","uri":"/ros-docker-dev-instruct/"},{"categories":null,"content":"6.修复本地包 include / import 错误 默认情况下 ROS 插件可能不会包含我们本地路径的包，这并不会导致编译错误，但是会导致我们无法使用智能提示。 msg 类型的包需先编译生成对应的 c++或者python头文件（在 devel 或者 install 中寻找对应目录） 这时候我们需要手动添加路径到 c_cpp_properties.json（注意每条路径后需要有个逗号： 提示：我们可以直接在左侧资源管理器中右键文件夹在弹出的菜单中复制文件夹的绝对路径 python 同理： 至此我们就能愉快的进行开发了，而且您还能保存自己的开发环境、推送到云端或者整理成压缩包进行分享，让团队中的所有人都能在几分钟之内拥有一致的开发环境，最重要的是还不会搞坏电脑本身的环境！ ","date":"2022-05-06","objectID":"/ros-docker-dev-instruct/:6:0","tags":null,"title":"一步到位解决开发环境一致性问题","uri":"/ros-docker-dev-instruct/"},{"categories":null,"content":"7. 远程开发实战 本节我们将运用上面所讲的知识，在松灵极其人 limo 套件上使用 docker 进行远程开发！ 首先运行docker 环境（docker 在默认系统中已经安装，这里我们不使用图形界面，不需要开启显卡支持） $ mkdir limo_foxy_dev \u0026\u0026 cd limo_foxy_dev $ docker run --network=host --cap-add=SYS_PTRACE --cap-add=SYS_RAWIO --security-opt=seccomp:unconfined --security-opt=apparmor:unconfined --volume=/tmp/.X11-unix:/tmp/.X11-unix --runtime=nvidia --device /dev/ttyTHS1:/dev/ttyTHS1 --device /dev/ttyUSB0:/dev/ydlidar --device /dev/bus/usb/:/dev/bus/usb -v $(pwd)/：workspace --name limo-foxy-dev -w /workspace -id ros:foxy $ docker exec -it limo-foxy-dev /bin/bash 这里我们挂载了底盘通信接口、激光雷达、USB 设备到我们的容器之中，以及将本地的 limo_foxy_dev 文件夹挂载到了容器中的 /workspace 之中并开启了一些相应的权限。 之后等待 docker 启动（第一次需要拉取远程镜像，速度稍慢，再次启动无需等待）进入之后可以看到如下界面： 接下来我们换源，提升下载速度： # 更换系统源 $ sed -i \"s/ports.ubuntu.com/mirrors.ustc.edu.cn/g\" /etc/apt/sources.list # 更换 ros2 源 $ sed -i \"s/packages.ros.org/repo.huaweicloud.com/g\" /etc/apt/sources.list.d/ros2-latest.list $ apt update 设置一下自动 source $ echo \"source /opt/ros/foxy/setup.bash\" \u003e\u003e /etc/bash.bashrc 安装 rosdepc 提升 rosdep 下载速度（注意这俩不是一个东西，多了个 c）： $ apt install -y python3-pip $ pip install rosdepc $ rosdepc init \u0026\u0026 rosdepc update 安装远程开发必备组件： $ apt install openssh-server systemctl udev swig # 分别为 远程连接组件 服务控制组件 驱动控制组件 雷达驱动组件 $ service ssh start $ echo -e \"Port 10022\\nPermitRootLogin yes\\nPermitEmptyPasswords yes\" \u003e\u003e /etc/ssh/sshd_config.d/dev.conf $ service ssh restart 重要！：如果容器重启后 ssh 无法连接请重新在容器中运行 service ssh start 设定密码： $ passwd # 之后输入新的密码（在这个过程中不会显示文字，输入完成按回车即可） 之后我们离开镜像，保证我们的小车和电脑在同一个局域网中，在本地电脑中打开 VSCode 使用 Remote ssh 插件连接镜像： 任选一个文件进行编辑： Host 名称自定义，HostName 是 limo 在局域网中的 ip，Port 是 ssh-server 连接的端口，用户是 root 保存退出。 如果大家不想使用 root 登陆请注意自定义用户组的权限，不然可能无法访问硬件（如雷达等） 重新打开 Connect to Host 选项，选择我们刚刚保存的条目进行连接： 之后会弹出一个新的窗口，在那里输入我们之前设定的密码: 之后打开我们挂载的 workspace 文件夹，这里会再次要求我们输入密码： 选择信任： 这里我在远程安装了如下插件方便我的开发： 之后打开命令行（快捷键 Shift+Ctrl+~)下载 ydlidar 的驱动并编译安装（当前目录 /workspace） $ git clone https://ghproxy.com/https://github.com/YDLIDAR/YDLidar-SDK.git # 使用了ghproxy.com 加速 $ mkdir -p YDLidar-SDK/build $ cd YDLidar-SDK/build $ cmake .. $ make $ make install # 安装 C/C++ 支持 $ cd .. $ pip install . # 安装 py 支持 $ cd .. \u0026\u0026 rm -r YDLidar-SDK # 删除 SDK 源码防止影响之后构建 请注意命令中 . 与 .. 的区别不要敲错了 下载 limo 的 ROS2 镜像（当前目录 /workspace）： $ git clone --recursive https://ghproxy.com/https://github.com/agilexrobotics/limo_ros2.git src # 使用了ghproxy.com 加速 修改 /workspace/src/ydlidar_ros2/src/ydlidar_ros2_driver_node.cpp 中源码参数： # 61 行 int optval = 115200; # 76 行 optval = 3; # 108 行 b_optvalue = true; # 134 行 f_optvalue = 12.f; # 143 行 f_optvalue = 8.f; 安装必要的支持库并编译（当前目录/workspace）： $ rosdepc install --from-paths src --ignore-src -r -y $ colcon build --symlink-install # 使用符号链接节省空间，如果要删除源码，则使用 --merge-install 会发现有一些标准错误输出，是正常的，不需要管。 之后 source 安装并启动雷达节点 $ source install/setup.bash $ ros2 launch limo_bringup limo_start.launch.py 然后在我们本地的电脑上打开我们本地的开发环境（也是在 Docker 中，根据上文所讲，使用的是 https://github.com/athackst/vscode_ros2_workspace 的模板） 在本地开发环境的终端中启动 rviz: $ rviz2 然后订阅雷达节点，按照图示进行配置 即可看到 limo 远程发来的雷达信息： 至此，我们便掌握了机器人远程开发的基础操作！熟悉这种方法可以极大的提升我们工作效率，降低机器人开发复杂度。 最后，感谢您的阅读！如果您喜欢本文请点赞分享，如有任何疑问请在官方仓库或者评论区进行提问。 ","date":"2022-05-06","objectID":"/ros-docker-dev-instruct/:7:0","tags":null,"title":"一步到位解决开发环境一致性问题","uri":"/ros-docker-dev-instruct/"},{"categories":["环境配置"],"content":"本文主要介绍我所使用的 ROS 开发环境 我采用这个模式进行开发是受到了这篇文章的启发：https://www.allisonthackston.com/articles/vscode-docker-ros2.html 如果您用过 ROS 就会发现配置这玩意儿的开发环境是一件非常麻烦的事情，经常会出现缺少支持库或者支持库冲突的情况，尤其是一台电脑上需要做多种任务的情况（比如 深度学习、QT开发、ROS1、ROS2）则会更糟糕。 这个时候我们就有必要使用 Docker 进行开发，关于如何使用 VSCode + Docker 进行开发的流程已经写在：Docker 配合 VSC 开发最佳实践，本文主要介绍如何配置 ROS 相关开发环境 如果您不会使用 docker 或者没有尝试过类似的操作，请您先阅读 Docker 配合 VSC 开发最佳实践 如果您使用 ROS-foxy 可以直接使用 https://github.com/athackst/vscode_ros2_workspace 作为您的工作目录，如果您需要使用 GPU 加速计算，则选择 带有 foxy-nvidia 的分支即可 下面我将带您从头配置相关文件 ","date":"2022-04-18","objectID":"/my_ros_env/:0:0","tags":["ROS","VSCode","Docker"],"title":"我的 ROS 开发环境","uri":"/my_ros_env/"},{"categories":["环境配置"],"content":"0. 新建目录 VSCode 会自动读取 .devcontainer 中的配置文件，目录结构如下： . ├── .devcontainer │ ├── devcontainer.json │ └── Dockerfile ","date":"2022-04-18","objectID":"/my_ros_env/:1:0","tags":["ROS","VSCode","Docker"],"title":"我的 ROS 开发环境","uri":"/my_ros_env/"},{"categories":["环境配置"],"content":"1. 选取开发镜像 这里我一直使用的是 https://hub.docker.com/u/althack 的镜像。 dockerfile 源码：https://github.com/athackst/dockerfiles 例如我最近需要使用 ROS-melodic + Gazebo 则会选择 https://hub.docker.com/r/althack/ros 中带有 melodic-gazebo 标签的镜像。 ","date":"2022-04-18","objectID":"/my_ros_env/:2:0","tags":["ROS","VSCode","Docker"],"title":"我的 ROS 开发环境","uri":"/my_ros_env/"},{"categories":["环境配置"],"content":"2. 配置 dockerfile 我们使用如下脚本 # 改编自 https://github.com/athackst/vscode_ros2_workspaceFROMalthack/ros:melodic-gazebo as gazebo # 我使用的镜像# ** [可选] 取消注释安装其他组件 **## ENV DEBIAN_FRONTEND=noninteractive# RUN apt-get update \\# \u0026\u0026 apt-get -y install --no-install-recommends \u003cyour-package-list-here\u003e \\# ## # Clean up# \u0026\u0026 apt-get autoremove -y \\# \u0026\u0026 apt-get clean -y \\# \u0026\u0026 rm -rf /var/lib/apt/lists/*# ENV DEBIAN_FRONTEND=dialog# 为 ros 用户配置自动 sourceARG WORKSPACERUN echo \"if [ -f ${WORKSPACE}/install/setup.bash ]; then source ${WORKSPACE}/install/setup.bash; fi\" \u003e\u003e /home/ros/.bashrc 如果需要 GPU 支持（需要安装 nvidia-docker) 则在上述脚本之后追加如下指令： RUN apt-get update \\ \u0026\u0026 apt-get install -y -qq --no-install-recommends \\ libglvnd0 \\ libgl1 \\ libglx0 \\ libegl1 \\ libxext6 \\ libx11-6 \\ \u0026\u0026 apt-get autoremove -y \\ \u0026\u0026 apt-get clean -y \\ \u0026\u0026 rm -rf /var/lib/apt/lists/*ENV DEBIAN_FRONTEND=dialog # Nvidia 运行时变量.ENV NVIDIA_VISIBLE_DEVICES allENV NVIDIA_DRIVER_CAPABILITIES graphics,utility,computeENV QT_X11_NO_MITSHM=1 ","date":"2022-04-18","objectID":"/my_ros_env/:3:0","tags":["ROS","VSCode","Docker"],"title":"我的 ROS 开发环境","uri":"/my_ros_env/"},{"categories":["环境配置"],"content":"3. 配置 devcontainer.json // 改编自 https://github.com/athackst/vscode_ros2_workspace // See https://aka.ms/vscode-remote/devcontainer.json for format details. { \"dockerFile\": \"Dockerfile\", \"build\": { \"args\": { \"WORKSPACE\": \"${containerWorkspaceFolder}\" } }, \"remoteUser\": \"ros\", \"runArgs\": [ \"--network=host\", \"--cap-add=SYS_PTRACE\", \"--security-opt=seccomp:unconfined\", \"--security-opt=apparmor:unconfined\", \"--volume=/tmp/.X11-unix:/tmp/.X11-unix\", // \"--gpus\" \"all\", // 取消该注释使用 GPU 功能 ], \"containerEnv\": { \"DISPLAY\": \"${localEnv:DISPLAY}\" }, // Set *default* container specific settings.json values on container create. \"settings\": { \"terminal.integrated.profiles.linux\": { \"bash\": { \"path\": \"bash\" }, }, \"terminal.integrated.defaultProfile.linux\": \"bash\" }, // 推荐安装的插件 \"extensions\": [ \"dotjoshjohnson.xml\", \"zachflower.uncrustify\", \"ms-azuretools.vscode-docker\", \"ms-iot.vscode-ros\", \"ms-python.python\", \"ms-vscode.cpptools\", \"redhat.vscode-yaml\", \"smilerobotics.urdf\", \"streetsidesoftware.code-spell-checker\", \"twxs.cmake\", \"yzhang.markdown-all-in-one\" ] } ","date":"2022-04-18","objectID":"/my_ros_env/:4:0","tags":["ROS","VSCode","Docker"],"title":"我的 ROS 开发环境","uri":"/my_ros_env/"},{"categories":["环境配置"],"content":"4. 构建镜像 我们使用 VSCode 打开文件夹，并且 Reopen in docker 即可（不要自己只使用 Dockerfile 进行构建，因为在 devcontainer.json 中我们还挂载了一些目录，添加了一些参数） ","date":"2022-04-18","objectID":"/my_ros_env/:5:0","tags":["ROS","VSCode","Docker"],"title":"我的 ROS 开发环境","uri":"/my_ros_env/"},{"categories":["环境配置"],"content":"5. 显示 容器 中的窗口 在宿主机中打开一个新的终端，输入： $ xhost + 之后再运行类似 Gazebo 等图形程序，其界面就会直接在我们的宿主机中显示出来。 ","date":"2022-04-18","objectID":"/my_ros_env/:6:0","tags":["ROS","VSCode","Docker"],"title":"我的 ROS 开发环境","uri":"/my_ros_env/"},{"categories":["环境配置"],"content":"作为一名炼丹师，我们经常需要使用 Nvidia 显卡辅助我们加速计算，但是 Docker 并不直接支持访问 Nvidia 显卡，但好在 Nvidia 官方提供了提供了相关 Docker 插件可以让我们直接在容器中访问 Nvidia 显卡 ","date":"2022-04-18","objectID":"/docker_with_nvidia/:0:0","tags":["Nvidia","Docker","Ubuntu"],"title":"在 Docker 中使用 Nvidia 显卡","uri":"/docker_with_nvidia/"},{"categories":["环境配置"],"content":"1. 查看安装专有驱动 想要使用 Nvidia 显卡，我们必须先要安装 Nvidia 官方驱动（默认情况下我们使用的是 开源驱动） 安装流程：https://zhuanlan.zhihu.com/p/388970072 ","date":"2022-04-18","objectID":"/docker_with_nvidia/:1:0","tags":["Nvidia","Docker","Ubuntu"],"title":"在 Docker 中使用 Nvidia 显卡","uri":"/docker_with_nvidia/"},{"categories":["环境配置"],"content":"2. 安装 Nvidia-docker 官方仓库：https://github.com/NVIDIA/nvidia-docker 安装指南：https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#docker 注意 本节使用 Ubuntu + docker2作为教程环境，其余发行版请参考官方安装指南 需要注意的是，在已经构建好的 容器 中改变这些环境变量不会有任何效果，如果您需要梗概配置还请 重新构建容器。 ","date":"2022-04-18","objectID":"/docker_with_nvidia/:2:0","tags":["Nvidia","Docker","Ubuntu"],"title":"在 Docker 中使用 Nvidia 显卡","uri":"/docker_with_nvidia/"},{"categories":["环境配置"],"content":"添加 GPG key 和 源 在终端执行如下指令： $ distribution=$(. /etc/os-release;echo $ID$VERSION_ID) \\ \u0026\u0026 curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \\ \u0026\u0026 curl -s -L https://nvidia.github.io/libnvidia-container/$distribution/libnvidia-container.list | \\ sed 's#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g' | \\ sudo tee /etc/apt/sources.list.d/nvidia-container-toolkit.list 之后更新 apt: $ sudo apt-get update ","date":"2022-04-18","objectID":"/docker_with_nvidia/:2:1","tags":["Nvidia","Docker","Ubuntu"],"title":"在 Docker 中使用 Nvidia 显卡","uri":"/docker_with_nvidia/"},{"categories":["环境配置"],"content":"安装 Nvidia-docker 使用如下指令安装： $ sudo apt-get install -y nvidia-docker2 成功后重启 docker： $ sudo systemctl restart docker 之后可以进行测试： $ sudo docker run --rm --gpus all nvidia/cuda:11.0-base nvidia-smi 应当能看到输出： +-----------------------------------------------------------------------------+ | NVIDIA-SMI 450.51.06 Driver Version: 450.51.06 CUDA Version: 11.0 | |-------------------------------+----------------------+----------------------+ | GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. | | | | MIG M. | |===============================+======================+======================| | 0 Tesla T4 On | 00000000:00:1E.0 Off | 0 | | N/A 34C P8 9W / 70W | 0MiB / 15109MiB | 0% Default | | | | N/A | +-------------------------------+----------------------+----------------------+ +-----------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=============================================================================| | No running processes found | +-----------------------------------------------------------------------------+ ","date":"2022-04-18","objectID":"/docker_with_nvidia/:2:2","tags":["Nvidia","Docker","Ubuntu"],"title":"在 Docker 中使用 Nvidia 显卡","uri":"/docker_with_nvidia/"},{"categories":["环境配置"],"content":"3. 使用说明 官方文档：https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/user-guide.html#gpu-enumeration 与未使用 nvidia 显卡的容器不同之处在于 nvidia-docker 多了一个 --gpus 参数，这个参数标明我们容器中可以使用哪些显卡（如果你的机器上有多张显卡的话） 一般情况下我们使用 docker --gpus all 即可，如果需要特别指名使用哪几张显卡，则可以使用类似 --gpus 0,1 指明使用 GPU UUID 为 0、1 的显卡 此外，根据不同情景需要我们还需要指名要在容器中安装哪些驱动程序或支持库，完整的列表见： https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/user-guide.html#driver-capabilities 比如我们需要 CUDA 和 nvidia-smi+NVML 支持，则需要这样 $ docker run --rm --gpus 'all,\"capabilities=compute,utility\"' \\ nvidia/cuda:11.0-base nvidia-smi 或者这样： # 传递环境变量的方式 $ docker run --rm --runtime=nvidia \\ -e NVIDIA_VISIBLE_DEVICES=2,3 \\ -e NVIDIA_DRIVER_CAPABILITIES=compute,utility \\ nvidia/cuda nvidia-smi 注意 需要注意的是，在已经构建好的 容器 中改变这些环境变量不会有任何效果，如果您需要梗概配置还请 重新构建容器。 ","date":"2022-04-18","objectID":"/docker_with_nvidia/:3:0","tags":["Nvidia","Docker","Ubuntu"],"title":"在 Docker 中使用 Nvidia 显卡","uri":"/docker_with_nvidia/"},{"categories":["环境配置"],"content":"结语 至此，在 Docker 中使用 nvidia 显卡的方法就介绍完毕了，如果您需要在 容器 中使用 Nvidia 相关支持库或者其他功能，则请参考官方文档。 ","date":"2022-04-18","objectID":"/docker_with_nvidia/:4:0","tags":["Nvidia","Docker","Ubuntu"],"title":"在 Docker 中使用 Nvidia 显卡","uri":"/docker_with_nvidia/"},{"categories":["松灵机器人"],"content":" 本文适合有 ROS1 基础和对 Gazebo 有了解的朋友 松灵机器人LIMO是全球首款集四种运动模态于一体的ROS开发平台，提供了适应场景更广泛、更符合行业应用要求的学习平台，适用于机器人教育、功能研发、产品开发。通过创新性的机械设计，能实现四轮差速、阿克曼、履带型、麦克纳姆轮运动模式的快速切换，可在配套的专业沙盘中快速建立多场景实拟教学和测试，LIMO搭载NVIDIA Jeston Nano、EAI XL2激光雷达、深度相机等高性能传感器配置，可实现精确的自主定位、SLAM建图、路线规划和自主避障、自主倒车入库、红绿灯识别等丰富功能。 此外，松灵为用户提供了 limo 的完整 gazebo 仿真支持库，本文将带您逐步上手使用： 教程素材地址：https://github.com/agilexrobotics/limo_courses/ ","date":"2022-04-18","objectID":"/gazebo_simulation/:0:0","tags":["limo","ROS1","Gazebo","仿真"],"title":"limo 仿真指南","uri":"/gazebo_simulation/"},{"categories":["松灵机器人"],"content":"1. 环境配置 在笔者提供的教程素材中已经配置好了相关的 Docker+VSCode 配置，在这里我们使用ROS-melodic + Gazebo9 作为仿真环境。 这里推荐使用 docker 作为开发环境，具体请移步 我的 ROS 开发环境 和 Docker 配合 VSC 开发最佳实践 如果启用 GPU 可以查看 在 Docker 中使用 Nvidia 显卡 下载教程素材： 推荐使用 git clone https://ghproxy.com/https://github.com/agilexrobotics/limo_courses/ 下载 进入 gazebo_simulation 目录。确保 ROS-melodic 已经配置成功后运行 setup_package.sh 脚本会自动安装相关环境。之后即可正常编译与运行： $ catkin_make $ source devel/setup.bash 如果遇到了类似如下错误： 请更换 Ubuntu 的源再进行尝试。 ","date":"2022-04-18","objectID":"/gazebo_simulation/:1:0","tags":["limo","ROS1","Gazebo","仿真"],"title":"limo 仿真指南","uri":"/gazebo_simulation/"},{"categories":["松灵机器人"],"content":"2. 开始仿真 ","date":"2022-04-18","objectID":"/gazebo_simulation/:2:0","tags":["limo","ROS1","Gazebo","仿真"],"title":"limo 仿真指南","uri":"/gazebo_simulation/"},{"categories":["松灵机器人"],"content":"查看车辆模型 limo_description 包主要为 limo 仿真模型，display_models.launch 为车辆在 Rviz 中的展示： $ roslaunch limo_description display_models.launch# 在 Rviz 中查看 可以得到如下界面： 此时我们没有运行任何仿真环境，所以不存在传感器信息。 ","date":"2022-04-18","objectID":"/gazebo_simulation/:2:1","tags":["limo","ROS1","Gazebo","仿真"],"title":"limo 仿真指南","uri":"/gazebo_simulation/"},{"categories":["松灵机器人"],"content":"gazebo 仿真 limo_gazebo_sim 包为 limo 车型在 gazebo 中的仿真，limo_xxx_.launch 为车型在不同模式下于 gazebo 中仿真展示 # 两种模式任选其一 $ roslaunch limo_gazebo_sim limo_ackerman.launch # 在 gazebo 中使用 阿卡曼 模式运动 # roslaunch limo_gazebo_sim limo_four_diff.launch # 以四轮差速 模式运动 可以看到 Gazebo 中出现了我们的小车： 注意 使用地图前需要补全 gazebo 的 models，不然会一直黑屏 并且 Rviz 中出现了 传感器 信息 这时，我们新开启一个终端运行： $ rosrun teleop_twist_keyboard teleop_twist_keyboard.py 则可以使用键盘控制 limo 进行移动 当然，您可能需要更换仿真所用的地图，这时候只需要修改 limo_gazebo_sim/launch 中所需运动模式文件中 world_name 标签参数即可： ","date":"2022-04-18","objectID":"/gazebo_simulation/:2:2","tags":["limo","ROS1","Gazebo","仿真"],"title":"limo 仿真指南","uri":"/gazebo_simulation/"},{"categories":["松灵机器人"],"content":"建图与保存 limo_bringup 为建图与导航功能包，首先启动我们的 gazebo（如果上一步的窗口没关，就不用新启动了）： # 两种模式任选其一 $ roslaunch limo_gazebo_sim limo_ackerman.launch # 使用 阿卡曼 模式运动 # roslaunch limo_gazebo_sim limo_four_diff.launch # 以四轮差速 模式运动 然后启动 gmapping 建图服务： $ roslaunch limo_bringup limo_gmapping.launch 之后即可在 rviz 中看到雷达地图： 注意 如果没有雷达地图出现，请在 Rviz 中手动订阅 /map 话题，并检查其余 display 项目中订阅话题是否正确。 打开 teleop_twist_keyboard，控制我们的小车在场地中溜达一圈以构建地图： $ rosrun teleop_twist_keyboard teleop_twist_keyboard.py 然后保存我们的地图： $ cd src/limo_bringup/maps $ rosrun map_server map_saver -f map1 即可保存我们的地图在 maps 中 ","date":"2022-04-18","objectID":"/gazebo_simulation/:3:0","tags":["limo","ROS1","Gazebo","仿真"],"title":"limo 仿真指南","uri":"/gazebo_simulation/"},{"categories":["松灵机器人"],"content":"自动导航 如果在这里您的地图存放到了别处或者名字不同，则需要修改启动文件 关闭上一步中我们的 gmapping 节点，启动 navigation : # 根据之前选择的运动模式进行选择： $ roslaunch limo_bringup limo_navigation_ackerman.launch # 阿卡曼模式 # roslaunch limo_bringup limo_navigation_diff.launch # 四轮差速模式 注意 这里最好重新启动一下 limo_gazebo_sim ，或者手动将小车开回原点，不然导航地图可能没法自动校准 4 等待服务启动以后我们回到 Rviz 中即可看到我们之前扫描的地图： 点击 Rviz 窗口上的 2D Nav Goal 并在地图选择一个点，即可看到小车会自动导航： ","date":"2022-04-18","objectID":"/gazebo_simulation/:3:1","tags":["limo","ROS1","Gazebo","仿真"],"title":"limo 仿真指南","uri":"/gazebo_simulation/"},{"categories":["松灵机器人"],"content":"3. 其他包的使用 除了官方提供的 gmapping 和 navigation 您也许想要尝试配置其他的包，这里只需要注意话题映射，limo 的 scan 和 imu 分别发布在了 /limo/scan 和 /limo/imu ，如果您的包需要订阅这两个话题则需要手动重新映射： ","date":"2022-04-18","objectID":"/gazebo_simulation/:4:0","tags":["limo","ROS1","Gazebo","仿真"],"title":"limo 仿真指南","uri":"/gazebo_simulation/"},{"categories":["松灵机器人"],"content":"4. 结语 至此，关于 limo 的仿真教程就结束了，如果您有任何疑问或者问题，欢迎在官方课程仓库提出 issu。 ","date":"2022-04-18","objectID":"/gazebo_simulation/:5:0","tags":["limo","ROS1","Gazebo","仿真"],"title":"limo 仿真指南","uri":"/gazebo_simulation/"},{"categories":null,"content":" 本文适合有 ROS1 基础与了解 urdf语法 和 gazebo 的朋友 SCOUT MINI 是一款全地形高速Mini UGV，具有四轮差速驱动、独立悬挂、原地差速自转等特点，得益于自主研发的轻量级动力系统解决方案，SCOUT MINI最大速度高达10KM/H，专为前沿科学实验设计的全能型移动研究平台。 此外，松灵为用户提供了 SCOUT MINI 的完整 gazebo 仿真支持库，本文将带您逐步上手使用： 仓库地址：https://github.com/agilexrobotics/ugv_gazebo_sim ","date":"2022-04-10","objectID":"/scout_mini_sim/:0:0","tags":["ROS","xacro","松灵机器人"],"title":"Scout mini 仿真指南","uri":"/scout_mini_sim/"},{"categories":null,"content":"1. 开发环境配置 目前官方提供的仿真环境是 ROS-melodic + gazebo9 ，如果您已配置好相关环境请跳过本节。 编者这里使用的开发环境是 docker + VSCode ，这个组合的好处可以参考我的博客文章：Docker 配合 VSC 开发最佳实践 我们首先新建工作空间文件夹，并使用 catkin 初始化工作空间： $ mkdir scout_ws \u0026\u0026 cd scout_ws $ mkdir src .devcontainer $ cd ../.devcontainer 在 .devcontainer 中新建 devcontainer.json 和 Dockerfile 两个文件： $ gedit devcontainer.json # 也可以自行更换其他的编辑器 在 devcontainer.json 保存如下内容： { \"dockerFile\": \"Dockerfile\", \"build\": { \"args\": { \"WORKSPACE\": \"${containerWorkspaceFolder}\" } }, \"remoteUser\": \"ros\", \"runArgs\": [ \"--network=host\", \"--cap-add=SYS_PTRACE\", \"--security-opt=seccomp:unconfined\", \"--security-opt=apparmor:unconfined\", \"--volume=/tmp/.X11-unix:/tmp/.X11-unix\" ], \"containerEnv\": { \"DISPLAY\": \"${localEnv:DISPLAY}\" }, // Set *default* container specific settings.json values on container create. \"settings\": { \"terminal.integrated.profiles.linux\": { \"bash\": { \"path\": \"bash\" }, }, \"terminal.integrated.defaultProfile.linux\": \"bash\" }, \"extensions\": [ \"dotjoshjohnson.xml\", \"zachflower.uncrustify\", \"ms-azuretools.vscode-docker\", \"ms-iot.vscode-ros\", \"ms-python.python\", \"ms-vscode.cpptools\", \"redhat.vscode-yaml\", \"smilerobotics.urdf\", \"streetsidesoftware.code-spell-checker\", \"twxs.cmake\", \"yzhang.markdown-all-in-one\" ] } 其中各个字段的具体含义可以参考我的博文 Docker 配合 VSC 开发最佳实践 $ gedit Dockerfile 在 Dockerfile 中保存以下内容： FROMalthack/ros:melodic-gazebo# Set up auto-source of workspace for ros userARG WORKSPACERUN echo \"if [ -f ${WORKSPACE}/install/setup.bash ]; then source ${WORKSPACE}/install/setup.bash; fi\" \u003e\u003e /home/ros/.bashrc 其中各个字段的具体含义可以参考我的博文 Docker 配合 VSC 开发最佳实践 此时，目录结构如下： scout_ws ├── .devcontainer │ ├── devcontainer.json │ └── Dockerfile └── src 使用 VSC 在 docker 中打开文件夹： $ cd scout_ws $ code . 后续具体操作请见：Docker 配合 VSC 开发最佳实践 最后，需要更新 apt 和 rosdep database $ sudo apt update $ rosdep update ","date":"2022-04-10","objectID":"/scout_mini_sim/:1:0","tags":["ROS","xacro","松灵机器人"],"title":"Scout mini 仿真指南","uri":"/scout_mini_sim/"},{"categories":null,"content":"2. 仿真环境配置 将https://github.com/agilexrobotics/ugv_gazebo_sim/tree/master/scout 中的 scout_control 、scout_description 、scout_gazebo_sim 三个文件放到 src目录之中。 安装如下 ROS 库： $ sudo apt-get -y install --no-install-recommends \\ ros-melodic-ros-control \\ ros-melodic-ros-controllers \\ ros-melodic-gazebo-ros \\ ros-melodic-gazebo-ros-control \\ ros-melodic-joint-state-publisher-gui \\ ros-melodic-teleop-twist-keyboard 然后初始化工作空间并安装依赖： $ cd scout_ws/src $ catkin_init_workspace $ cd .. $ rosdep install --from-paths src --ignore-src -r -y 即可正常编译与运行： $ catkin_make $ source devel/setup.bash scout_description 包主要为 scout 系列车型仿真模型，display_xxx_.launch 为不同车型在 Rviz 中的展示： $ roslaunch scout_description display_mini_models.launch # 在 Rviz 中查看 scout mini 车型 scout_gazebo_sim 包为 scout 系列车型在 gazebo 中的仿真，scout_xxx_.launch 为不同车型在 gazebo 中仿真展示 $ roslaunch scout_gazebo_sim scout_mini_empty_world.launch # 在 gazebo 中使用空地图仿真 scout mini 注意 使用 playpen 地图前需要补全 gazebo 的 models，不然会一直黑屏 ","date":"2022-04-10","objectID":"/scout_mini_sim/:2:0","tags":["ROS","xacro","松灵机器人"],"title":"Scout mini 仿真指南","uri":"/scout_mini_sim/"},{"categories":null,"content":"3. 添加自定义传感 官方的仿真模型中并未添加现成传感器，这也很好理解——车辆上本来就没有，无故添加反而会在实际使用中让人疑惑。 scout 系列车型的 urdf 描述文件位于 scout_description/urdf 中，在这里我们并未直接使用 urdf 文件进行描述，而是从 xacro （xml macro) 描述文件中生成 urdf 信息。使用 xacro 的好处在于我们可以像编程一样实现复用一些 urdf 节点以及将不同的组件拆分等功能。 如果您不了解 xacro，可以先阅读 xacro 语法说明：http://wiki.ros.org/xacr 其相当于扩展了 urdf 的语法，可以以更便捷的方式描述我们的机器人。 下面我将带大家使用 xacro 为小车加上一个简易摄像头： 首先在我们的 scout_description/urdf 中添加一个名为 universal_sensor_adder.xacro 的文件，其中保存如下内容： \u003c?xml version=\"1.0\"?\u003e \u003c!-- Author: AnthonySuen Date: 2020-4-8 --\u003e \u003crobot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"universal_sensor_adder\"\u003e \u003c!-- 用于生成一个新的传感器节点, x_offset y_offset z_offset r p y对应于传感器和 base_link 的相对位置 sensor_config 为传感器的配置信息 sensor_plugin_config 为 gazebo 相关插件的配置内容 --\u003e \u003cxacro:macro name=\"add_sensor\" params=\"sensor_name type x_offset y_offset z_offset r p y **sensor_config **sensor_plugin_config\"\u003e \u003clink name=\"sensor_${sensor_name}\"\u003e \u003c!-- 配置传感器视觉信息 --\u003e \u003cvisual\u003e \u003cgeometry\u003e \u003cbox size=\"0.03 0.05 0.05\"/\u003e \u003c/geometry\u003e \u003cmaterial name=\"red\"\u003e \u003ccolor rgba=\"1.0 0.0 0.0 1.0\"/\u003e \u003c/material\u003e \u003c/visual\u003e \u003c!-- 配置碰撞体积, 为gazebo仿真使用 --\u003e \u003ccollision\u003e \u003corigin xyz=\"0.0 0.0 0.0\" rpy=\"0.0 0.0 0.0\"/\u003e \u003cgeometry\u003e \u003cbox size=\"0.03 0.05 0.05\"/\u003e \u003c/geometry\u003e \u003c/collision\u003e \u003c!-- 配置惯性矩阵, 用于 gazebo 仿真,这里我假设传感器很轻很小 --\u003e \u003cinertial\u003e \u003corigin xyz=\"0.0 0.0 0.0\" rpy=\"0.0 0.0 0.0\"/\u003e \u003cmass value=\"1e-5\"/\u003e \u003cinertia ixx=\"1e-6\" ixy=\"1e-6\" ixz=\"1e-6\" iyy=\"1e-6\" iyz=\"1e-6\" izz=\"1e-6\"/\u003e \u003c/inertial\u003e \u003c/link\u003e \u003c!-- 配置关节信息, 这里我默认传感器是固定在车上的 --\u003e \u003cjoint name=\"sensor_${sensor_name}_joint\" type=\"fixed\"\u003e \u003cparent link=\"base_link\"/\u003e \u003cchild link=\"sensor_${sensor_name}\"/\u003e \u003corigin xyz=\"${x_offset} ${y_offset} ${z_offset}\" rpy=\"${r} ${p} ${y}\"/\u003e \u003c/joint\u003e \u003c!-- gazebo 配置仿真配置部分 --\u003e \u003cgazebo reference=\"sensor_${sensor_name}\"\u003e \u003c!-- 此部分要与 传感器 link 名称保持一致 --\u003e \u003csensor name=\"${sensor_name}\" type=\"${type}\"\u003e \u003c!-- 这里会插入传感器自身配置信息和相关插件的配置内容 --\u003e \u003cxacro:insert_block name=\"sensor_config\"/\u003e \u003cxacro:insert_block name=\"sensor_plugin_config\"/\u003e \u003c/sensor\u003e \u003c/gazebo\u003e \u003c/xacro:macro\u003e \u003c/robot\u003e 注意 请在使用时删除中文注释，xacro 无法解析非 ascii 字符！ 编辑 empty.urdf 文件，修改其中内容如下： \u003c?xml version=\"1.0\"?\u003e \u003c!-- Author: AnthonySuen Date: 2020-4-8 --\u003e \u003crobot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"sensors\"\u003e \u003c!-- 加载我们之前编写的文件，之后可以使用其中相关内容 --\u003e \u003cxacro:include filename=\"$(find scout_description)/urdf/universal_sensor_adder.xacro\" /\u003e \u003c!-- 使用我们编写的函数，填入相关参数 --\u003e \u003cxacro:add_sensor sensor_name=\"camera\" type=\"camera\" x_offset=\"0.1\" y_offset=\"0.0\" z_offset=\"0.085\" r=\"0.0\" p=\"0.0\" y=\"0.0\"\u003e \u003c!-- 这部分会替换 \u003cxacro:insert_block name=\"sensor_config\"/\u003e 中的内容 --\u003e \u003csensor_config\u003e \u003cupdate_rate\u003e30\u003c/update_rate\u003e \u003ccamera name=\"general_camera\"\u003e \u003cimage width=\"640\" height=\"480\" hfov=\"1.5708\" format=\"RGB8\" near=\"0.01\" far=\"50.0\"/\u003e \u003c/camera\u003e \u003c/sensor_config\u003e \u003c!-- 这部分会替换 \u003cxacro:insert_block name=\"sensor_plugin_config\"/\u003e 中的内容 --\u003e \u003csensor_plugin_config\u003e \u003cplugin name=\"general_camera_controller\" filename=\"libgazebo_ros_camera.so\"\u003e \u003calwaysOn\u003etrue\u003c/alwaysOn\u003e \u003cupdateRate\u003e36.0\u003c/updateRate\u003e \u003ccameraName\u003esensor_camera\u003c/cameraName\u003e \u003cimageTopicName\u003eimage_raw\u003c/imageTopicName\u003e \u003ccameraInfoTopicName\u003ecamera_info\u003c/cameraInfoTopicName\u003e \u003cframeName\u003esensor_camera\u003c/frameName\u003e \u003c!-- 需要与 传感器 link 名称保持一致 --\u003e \u003chackBaseline\u003e0.1\u003c/hackBaseline\u003e \u003cdistortionK1\u003e0.0\u003c/distortionK1\u003e \u003cdistortionK2\u003e0.0\u003c/distortionK2\u003e \u003cdistortionK3\u003e0.0\u003c/distortionK3\u003e \u003cdistortionT1\u003e0.0\u003c/distortionT1\u003e \u003cdistortionT2\u003e0.0\u003c/distortionT2\u003e \u003c/plugin\u003e \u003c/sensor_plugin_config\u003e \u003c/xacro:add_sensor\u003e \u003c/robot\u003e empty.urdf 会在我们模型生成的时候被 mini.xacro 等车辆描述文件加载，所以我们不用去更改其他模型文件，这样保持了开发的整洁性 注意 请在使用时删除中文注释，xacro 无法解析非 ascii 字符 之后运行一下 Rivz 查看我们修改后的模型： $ roslaunch scout_description display_mini_models.launch 可以看到车辆头顶出了一个红色小方块，这就是我们的简易摄像头模型 也可以在 gazebo 中仿真并用 Rviz 接收图像： $ roslaunch scout_gazebo_sim scout_mini_playpen.launch 至此，便完成了添加传感器并进行仿真的全部流程，对于其他类型传感器，诸如 深度相机 激光雷达 imu 等，其添加方法一样方便，唯一不同点在我们编写的函数中 sensor_config 与 sensor_plugin_config 块中对于不同传感器的配置，简单修改即可适配不同传感器。 ","date":"2022-04-10","objectID":"/scout_mini_sim/:3:0","tags":["ROS","xacro","松灵机器人"],"title":"Scout mini 仿真指南","uri":"/scout_mini_sim/"},{"categories":["开发技巧","环境配置"],"content":"由于一些原因，我们常常需要在开发中使用代理，但是在实践过程中我们发现在 Container 中我们无法直接使用主机配置好的代理。本文将给出不同平台下配置 Container 中的代理的方法。 警告 本文的目的是为工作提供方便，很多公司开发过程中都需要使用代理连接内部资源服务器，请勿将本文所述内容用于违法用途！ 对此产生的任何影响本人概不负责！ ","date":"2022-01-26","objectID":"/docker-proxy-complete-solution/:0:0","tags":["Docker","Docker-Desktop","Container","proxy"],"title":"Docker Container 代理配置一本通","uri":"/docker-proxy-complete-solution/"},{"categories":["开发技巧","环境配置"],"content":"综述 对于 Container 的配置分为两种情况： 使用Dockerfile/Docker-compose分步构建过程中是需要使用代理 例如需要使用公司内部镜像下载软件包 构建好的容器需要使用代理 对于上述两种情况，经过查阅 Docker 相关文档，所有平台下对 Container 的代理配置都可以转化为一个操作： 在 Container 中设置 http_proxy / https_proxy 这两个环境变量 注意 注意这里的大小写，如果只设置了 HTTP_proxy / HTTPS_proxy 可能在某些情况下无法正常工作，当然您也可以一块儿将这四个变量都设置了，不影响的。 ","date":"2022-01-26","objectID":"/docker-proxy-complete-solution/:1:0","tags":["Docker","Docker-Desktop","Container","proxy"],"title":"Docker Container 代理配置一本通","uri":"/docker-proxy-complete-solution/"},{"categories":["开发技巧","环境配置"],"content":"配置方法 Docker 支持设定时给每个新构建的 Container 传递永久环境变量，有些人利用这一点直接传递 xxxx_proxy，但是我不希望你这样做 永久环境变量可能出现的问题 如果你构建的镜像内部永久配置了 http_proxy 等 代理环境变量，那可能会导致你的镜像在别人那里运行就会出现网络问题，而对方可能对 Docker 或者 Linux 理解不深从而没有办法修复这个问题，这不符合一次构建到处运行的理念。 在正式开始之前，我们需要确定我们的代理已经允许了本地 LAN 并配置好了端口： ","date":"2022-01-26","objectID":"/docker-proxy-complete-solution/:2:0","tags":["Docker","Docker-Desktop","Container","proxy"],"title":"Docker Container 代理配置一本通","uri":"/docker-proxy-complete-solution/"},{"categories":["开发技巧","环境配置"],"content":"确定 http(s)_proxy 地址 在实际的使用中，我们需要传递的环境变量 http_proxy 和 https_proxy （当然，你也可以继续传递 类似 ftp_proxy 等内容） 这时候对于不同平台我们需要使用不同的地址： Windows / MacOs： 由于在这两个平台下 Docker 通过 NAT 的方式连接网络，我们无法获取一个固定的网关地址，所以 Docker-Desktop 为我们提供了一个访问网关的网址：gateway.docker.internal，所以我们直接使用这个地址即可。 示例 https_proxy=\"https://gateway.docker.internal:7890\" http_proxy=\"http://gateway.docker.internal:7890\" Linux Linux 下 docker 服务默认会创建一个 docker0 网桥，我们可以通过这个网桥让容器和主机进行通信，只需要在命令行输入： $ ip addr show docker0 就可以看到 docker0 的信息： 4: docker0: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc noqueue state UP group default link/ether 02:42:84:54:33:33 brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever inet6 fe80::42:84ff:fe54:3333/64 scope link valid_lft forever preferred_lft forever 这里面 inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 就表示我们容器的网关为 172.17.0.1，我们使用网关即可直接访问我们主机： 示例 https_proxy=\"https://172.17.0.1:7890\" http_proxy=\"http://172.17.0.1:7890\" ","date":"2022-01-26","objectID":"/docker-proxy-complete-solution/:2:1","tags":["Docker","Docker-Desktop","Container","proxy"],"title":"Docker Container 代理配置一本通","uri":"/docker-proxy-complete-solution/"},{"categories":["开发技巧","环境配置"],"content":"从 Dockerfile 构建 注意 以下示例均已 Linux 的为例，Windows/MacOs 用于请自行替换相应的地址！，怎么确定请往上面看！确定 http(s)_proxy 地址 1. 永久传递环境变量 使用 ENV 参数，这样传递进去的参数在此之后会一直留存在镜像之中： FROMubuntu as base# 放在开头，之后的指令就都会被这两条环境变量影响ENV https_proxy=\"https://172.17.0.1:7890\"ENV http_proxy=\"http://172.17.0.1:7890\"# 其余命令 2. 仅在构建时传递 使用 ARG 参数，这样两条代理指令仅在构建过程中起效，构建结束后的 Image 中不会留存相关环境变量： FROMubuntu as base# 放在开头，之后的指令就都会被这两条环境变量影响ARG https_proxy=\"https://172.17.0.1:7890\"ARG http_proxy=\"http://172.17.0.1:7890\"# 其余命令 ","date":"2022-01-26","objectID":"/docker-proxy-complete-solution/:2:2","tags":["Docker","Docker-Desktop","Container","proxy"],"title":"Docker Container 代理配置一本通","uri":"/docker-proxy-complete-solution/"},{"categories":["开发技巧","环境配置"],"content":"构建好的 Image 注意 以下示例均已 Linux 的为例，Windows/MacOs 用于请自行替换相应的地址！，怎么确定请往上面看！确定 http(s)_proxy 地址 对于已经构建好的 Image，我们对其配置代理有两种方式： 1. 传递永久环境变量 在启动的时候传入参数： 示例 $ docker run --rm -it\\ -e https_proxy=\"https://gateway.docker.internal:7890\"\\ -e http_proxy=\"http://gateway.docker.internal:7890\"\\ ubuntu # 这里换成你需要的image名 当然，您可也可以将这写环境变量写成一个 .env 文件然后使用 --env-file 去统一导入： 例如 Linux 下.env 文件： http_proxy=\"http://172.17.0.1:7890\" https_proxy=\"https://172.17.0.1:7890\" 之后这要进行导入： $ docker run --rm -it --env-file .env ubuntu 2. 临时传递 临时传递的方式较为简单，只需要先运行镜像： $ docker run --rm -it ubuntu 在进入镜像后手动设置环境变量： $ export http_proxy=\"http://172.17.0.1:7890\" $ export https_proxy=\"https://172.17.0.1:7890\" 或者配合 VSCode 的 Remote-Container 插件配置后可以实现每次自动设置，具体方式请移步 Docker 配合 VSC 开发最佳实践 ","date":"2022-01-26","objectID":"/docker-proxy-complete-solution/:2:3","tags":["Docker","Docker-Desktop","Container","proxy"],"title":"Docker Container 代理配置一本通","uri":"/docker-proxy-complete-solution/"},{"categories":["开发技巧","环境配置"],"content":"已生成的 Container 注意 以下示例均已 Linux 的为例，Windows/MacOs 用于请自行替换相应的地址！，怎么确定请往上面看！确定 http(s)_proxy 地址 1. 永久设定环境变量 修改 /etc/profile 或者 ~/.bashrc 文件，在其中加入 export http_proxy=\"http://172.17.0.1:7890\" export https_proxy=\"https://172.17.0.1:7890\" 2. 临时设定 在进入镜像后手动设置环境变量： $ export http_proxy=\"http://172.17.0.1:7890\" $ export https_proxy=\"https://172.17.0.1:7890\" 或者配合 VSCode 的 Remote-Container 插件配置后可以实现每次自动设置，具体方式请移步 Docker 配合 VSC 开发最佳实践 ","date":"2022-01-26","objectID":"/docker-proxy-complete-solution/:2:4","tags":["Docker","Docker-Desktop","Container","proxy"],"title":"Docker Container 代理配置一本通","uri":"/docker-proxy-complete-solution/"},{"categories":["开发技巧","环境配置"],"content":"结语 以上就是配置 Docker 容器代理的全部方法，经过实践真实可用 ","date":"2022-01-26","objectID":"/docker-proxy-complete-solution/:3:0","tags":["Docker","Docker-Desktop","Container","proxy"],"title":"Docker Container 代理配置一本通","uri":"/docker-proxy-complete-solution/"},{"categories":null,"content":"emm…看起来这里还有写完 ","date":"2022-01-23","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":["开发技巧"],"content":"前言 ","date":"2022-01-23","objectID":"/docker-with-vsc_best-practice/:1:0","tags":["Docker","VSCode"],"title":"Docker配合VSC开发最佳实践","uri":"/docker-with-vsc_best-practice/"},{"categories":["开发技巧"],"content":"为什么我们需要虚拟环境？ 很长时间以来最让我头疼的事情就是配置开发环境，最简单的一个例子是配置深度学习使用的 Python 环境。如果在本机上直接配置 Python 环境很容易出现各种问题，例如 Pytorch 和 Tensorflow 可能会同时依赖某个库的不同版本，这就会导致可能只有特定版本 Pytorch 和 Tensorflow 才有机会共存，而你在安装的时候很可能都没有意识到这个问题。 直到你运行某段代码时 Python 解释器给你报了几百行的错误你才意识哪里出了点问题，但是你又不知道是什么，于是你就会花上几天的时间改代码、查资料，最后你明白是你的环境配置有问题，于是又手动清理之前安装错误的 Python 库，并尝试重新运行之前的代码。 警告 当然，更多的时候这会开启新一个痛苦的轮回 Python 环境配置建议 所幸，现在我们可以使用 Anaconda 进行 Python 环境管理，不同的环境相互隔离以免出现冲突。conda 对于依赖的检查也比 pip 更好用，基本上不会出现依赖冲突问题 这一套的流程下来我相信无论是谁也受不了，但是环境问题远不止如此 环境问题示例 某段代码只能在某几个特定的电脑上才能运行 某段代码你睡了一觉后就无法运行了 你辛苦配了好久的环境不好使了/需要换电脑了/需要给别人也整一份 你有两项工作要做，但是这两项工作需要安装的包是冲突的，而且重新安装极其麻烦 你安装了某个包，然后你的操作系统就出了问题，即使卸载这个包也没有用 你想在 Linux 上使用 N卡 于是你按照网上的教程配置了显卡，然后你的显卡就不好使了 某个古董程序只能在老版 Linux 上运行 …… 应对以上问题，我们当然可以简单的给电脑做多系统/每次重装系统/买新的电脑来解决，但更为经济的做法是使用容器技术。 ","date":"2022-01-23","objectID":"/docker-with-vsc_best-practice/:1:1","tags":["Docker","VSCode"],"title":"Docker配合VSC开发最佳实践","uri":"/docker-with-vsc_best-practice/"},{"categories":["开发技巧"],"content":"Docker VS 虚拟机 快 Docker 的启停都是以秒或者毫秒为单位的，诸如 VM 等软件的启停最少也需要几分钟的时间 只要使用一行指令 / 一个 Dockerfile/docker-compose 文件 即可快速启动/部署我们的环境 轻量 Docker 环境不需要虚拟完整的操作系统或者硬件镜像体积天生就小，且基于联合文件系统可以让不同镜像间使用到的相同文件进行共用，进一步压缩了镜像体积。（一些常用的开发环境甚至只有不到 100M） 虚拟机需要大量的资源去虚拟完整的操作系统甚至是硬件无法实现多开；Docker 只占用很少的运行时资源，一台机器可以开启少则几十多则几百上千个 Docker Container 快速回滚 容器技术天生带有回滚属性，因为每个历史容器或者镜像都会有保存，而替换一个容器或者某个历史镜像是非常快速和简单的，你可以快速回到某一次的更改 隔离性强 一台机器上可以启动多个 Docker 容器，而且容器之间环境隔离不会互相干扰 易分享 你只需要将你的 Container 镜像推送到云端或者直接分享给你的 Dockerfile/docker-compose 文件给其他人即可让其他人在几分钟内快速部署和你相同的环境 你能够保证其他人都能使用和你一模一样的镜像 Docker 是跨平台的产品，同样的镜像可以在 Windows / MacOs / Linux 上同时使用，而且效果相同 低成本 一台机器上可以启动几十上百个 Docker 容器 使用 Docker Swarm / K8s 等编排工具可以快速编排管理成百上千的容器 ","date":"2022-01-23","objectID":"/docker-with-vsc_best-practice/:1:2","tags":["Docker","VSCode"],"title":"Docker配合VSC开发最佳实践","uri":"/docker-with-vsc_best-practice/"},{"categories":["开发技巧"],"content":"VSCode 与 Docker 结合 VSCode 是什么相信我不必多言，依托于其 Remote Container 插件，我们可以快速地（真的很快🚀）连接到 Docker 容器中去，实现在本地编写程序，一键容器中调试运行——而这一切跟你直接在宿主机上开发几乎一模一样。而用虚拟机的话光是不同屏幕之间切换以及文件同步之类的操作就够惹人烦了。 再者，配合 VSCode 原生的 launch 和 task 配置并绑定相应段快捷键，我们可以节省很多应用编译时需要进行的操作（比如输入编译指令、清理目录等） ","date":"2022-01-23","objectID":"/docker-with-vsc_best-practice/:1:3","tags":["Docker","VSCode"],"title":"Docker配合VSC开发最佳实践","uri":"/docker-with-vsc_best-practice/"},{"categories":["开发技巧"],"content":"Docker 学习 Docker 网络上的教程有很多，我相信我很难讲出比现有课程更好的效果，在这里我只推荐我认为讲的最好的一个课程，内容精简实践性强，大概花上两个下午就能学完。 【狂神说Java】Docker最新超详细版教程通俗易懂 以及进阶版： 【狂神说Java】Docker进阶篇超详细版教程通俗易懂 学完了这两门课程我相信你基本上能够熟练地是使用 Docker 了，下一节我们来说如何让 VSCode 连接 Docker 环境 ","date":"2022-01-23","objectID":"/docker-with-vsc_best-practice/:2:0","tags":["Docker","VSCode"],"title":"Docker配合VSC开发最佳实践","uri":"/docker-with-vsc_best-practice/"},{"categories":["开发技巧"],"content":"VSCode 连接 Container 注意 在进行本节内容之前请先确保你已经学会了 Docker 相关知识 ","date":"2022-01-23","objectID":"/docker-with-vsc_best-practice/:3:0","tags":["Docker","VSCode"],"title":"Docker配合VSC开发最佳实践","uri":"/docker-with-vsc_best-practice/"},{"categories":["开发技巧"],"content":"Remote Containers 插件安装 插件市场插件市场 \" 插件市场 打开插件市场（图中 ① 箭头所示） 在搜索框输入 container 搜索插件（图中 ③ 所示） 找到 Remote-Containers 插件在打开的页面中安装插件（途中 ② 所示） 等待插件安装成功之后应该能发现在 VSCode 左下角出现一个新的小图标，左边也出现了一个 Docker 图标 新图标新图标 \" 新图标 ","date":"2022-01-23","objectID":"/docker-with-vsc_best-practice/:3:1","tags":["Docker","VSCode"],"title":"Docker配合VSC开发最佳实践","uri":"/docker-with-vsc_best-practice/"},{"categories":["开发技巧"],"content":"Remote Containers 插件使用 严格上来讲本节内容是对 Remote-Containers 插件 官方文档 的翻译与浓缩。 初体验 在 https://github.com/microsoft/vscode-remote-try-python 下载解压官方示例仓库并使用 VSCode 打开文件夹，您应该得到如下组织的目录： . │ .gitattributes │ .gitignore │ app.py │ LICENSE │ README.md │ requirements.txt │ ├─.devcontainer │ devcontainer.json │ Dockerfile │ ├─.vscode │ launch.json │ └─static index.html 在根目录用 VS Code 打开文件夹，然后点击左下角的图标 点击新图标点击图标 \" 点击新图标 在弹出的窗口中选择 Reopen in Container 在容器中打开在容器中打开 \" 在容器中打开 VS Code 会根据 .devcontainer 文件夹中的 Dockerfile 和 devcontainer.json 自动拉取并配置镜像环境，点击蓝色字样（show log）可以查看当前环境构建进度 点击查看当前构建过程点击查看当前构建过程 \" 点击查看当前构建过程 首先 VS Code 会根据 Dockerfile 文件描述进行 build image 并 docker run 生成 container 根据 Dockerfile 构建镜像根据 Dockerfile 构建镜像 \" 根据 Dockerfile 构建镜像 紧接着，VS Code 会根据 devcontainer.json 文件中的描述进行一些配置工作，比如这里会在 container 首次运行的时候执行 $ pip3 install -r requirements.txt 来安装运行 python 程序需要的支持库 首次启动首次启动 \" 首次启动 以及会根据 devcontainer.json 中的配置为我们的 container 自动安装一些插件，比如这里会提示 Pylance 需要重新加载窗口来激活： Pylance 提示Pylance 提示 \" Pylance 提示 这里我们选择 是 等待窗口加载完毕后点击窗口左侧的 运行和调试功能 运行与调试按钮运行与调试按钮 \" 运行与调试按钮 点击 开始调试 ，VS Code 会自动帮我们运行这个 python 程序 开始调试开始调试 \" 开始调试 关于 VS Code 的调试功能和 Task 功能是另外的话题，我会单独讲解，这里不会深入。 这时候我们发现 VS Code 帮我们自动转发了 python 程序提供的端口（真的非常方便✨） 端口自动转发端口自动转发 \" 端口自动转发 点击在 浏览器中打开 即可看到这段程序提供的网页内容： 而这一切只会花费不到五分钟（根据网速而定），而且不会对宿主机产生任何影响！ devcontainer.json 探究 Dockerfile 在 Docker 学习 章节已经讲过了，这里我就不介绍了。我们主要来探究 devcontain.json 到底讲了什么故事。 详细文档和例子请见 https://aka.ms/vscode-remote/devcontainer.json ，这里我们主要来看一下常用的一些配置信息： name 当前工作空间名称，会显示在左下角 build dockerfile： 用于指定 dockerfile 文件的路径，这里是相对于 devcontainer.json 文件而言 context：用于指定 docker build 时的上下文路径，这里是相对于 devcontainer.json 文件而言 args：用于在 docker build 时传递参数 settings 用于设定容器中 settings.json 的默认值，比如这里设定了使用的 shell 路径和 python 插件的配置 extensions 用于指定在容器中安装的插件，比如这里会自动帮我们安装 pylance 插件 portsAttributes 用于设定端口属性，比如名称，映射时的行为，也可以用 forwardPorts 简单代替 postCreateCommand 在容器第一次启动时执行的指令，这里会自动安装依赖，只会执行这一次 remoteUser 登录到容器的用户名，默认情况下是 root 用户登录，但是有时我们不想这样，可以利用这个指定远程用户名（这个用户必须存在才行） 此外，还有一些字段也很有用： runArgs docker run 时传递的参数，用于类似设定 –network=host 等操作 containerEnv / remoteEnv 用于设定容器中的环境变量，比如设定 http_proxy 等环境变量的值 ","date":"2022-01-23","objectID":"/docker-with-vsc_best-practice/:3:2","tags":["Docker","VSCode"],"title":"Docker配合VSC开发最佳实践","uri":"/docker-with-vsc_best-practice/"},{"categories":["开发技巧"],"content":"显示 Docker 中的图形界面 很多时候我们都需要查看 docker 中的图形界面，这里我们直接使用 X11 让 docker 中的 GUI 直接在宿主机上运行（相比于 VNC 方案更加轻量化） 现成的方案有这几个： 在docker中通过X11运行gui程序 Docker X11 穿透方案 上面两个文章讲了原理和操作方法，下面给出如何在 VS Code 中配置 首先我们在 devcontainer.json 中的 runArgs 字段中添加 \"--volume=/tmp/.X11-unix:/tmp/.X11-unix\" 表示挂载 x11 相关目录到容器中 containerEnv 字段中添加 \"DISPLAY\": \"${localEnv:DISPLAY}\" 表示设定容器中的 DISPLAY 环境变量与本地 DISPLAY 为一样的值，例如： { \"dockerFile\": \"Dockerfile\", \"build\": { \"args\": { \"WORKSPACE\": \"${containerWorkspaceFolder}\" } }, \"remoteUser\": \"ros\", \"runArgs\": [ \"--network=host\", \"--cap-add=SYS_PTRACE\", \"--security-opt=seccomp:unconfined\", \"--security-opt=apparmor:unconfined\", \"--volume=/tmp/.X11-unix:/tmp/.X11-unix\", // \"--gpus\" \"all\", // 取消注释使用 GPU 功能 ], \"containerEnv\": { \"DISPLAY\": \"${localEnv:DISPLAY}\" }, // Set *default* container specific settings.json values on container create. \"settings\": { \"terminal.integrated.profiles.linux\": { \"bash\": { \"path\": \"bash\" }, }, \"terminal.integrated.defaultProfile.linux\": \"bash\" } 最后，在我们的主机中打开一个命令行，输入： $ xhost + 来允许我们的容器在宿主机上显示窗口。 至此即可完成将容器中 GUI 显示在宿主机的操作！ ","date":"2022-01-23","objectID":"/docker-with-vsc_best-practice/:4:0","tags":["Docker","VSCode"],"title":"Docker配合VSC开发最佳实践","uri":"/docker-with-vsc_best-practice/"},{"categories":["开发技巧"],"content":"结语 至此 Docker 配合 VSCode 开发的内容就讲解完毕了，如果大家觉得有哪里需要改进或者拓展的地方还请在评论区提出，我会及时回复. ","date":"2022-01-23","objectID":"/docker-with-vsc_best-practice/:5:0","tags":["Docker","VSCode"],"title":"Docker配合VSC开发最佳实践","uri":"/docker-with-vsc_best-practice/"},{"categories":null,"content":" 基本信息 - nickname:Anthonyavatar:https://anthonysun256.github.io/images/avatar.jpgurl:https://anthonysun256.github.iodiscription:Anthony's blog ","date":"0001-01-01","objectID":"/friends/:0:0","tags":null,"title":"友情链接","uri":"/friends/"},{"categories":null,"content":"友情提醒 互换友链请按以上格式在评论留言。（仅限个人非商业博客/网站） 提醒：网站失效、停止维护、内容不当都可能被取消连接！ 那些不尊重他人劳动成果，转载不加出处的，或恶意行为的网站，还请您不要来进行交换了。 ","date":"0001-01-01","objectID":"/friends/:1:0","tags":null,"title":"友情链接","uri":"/friends/"}]